<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Car Adventure</title>

    <!-- ======================== CSS STYLES ======================== -->
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }

        /* ---------- Debug Panel (BLE status overlay) ---------- */
        #debug-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 340px;
            background: transparent;
            color: #0f0;
            padding: 15px;
            border: none;
            font-family: monospace;
            z-index: 10000;
            font-size: 10px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #debug-panel .status-connected {
            color: #0f0;
        }

        #debug-panel .status-disconnected {
            color: #f00;
        }

        #debug-panel .status-connecting {
            color: #ff0;
        }

        #debug-panel .vibe-success {
            color: #0f0;
        }

        #debug-panel .vibe-fail {
            color: #f00;
        }

        /* ---------- Loading Screen ---------- */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 0.5s;
        }

        /* ---------- Heads-Up Display (score, difficulty) ---------- */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px #000;
            z-index: 10;
            pointer-events: none;
            text-align: left;
        }

        #hud button {
            pointer-events: auto;
        }

        /* ---------- Lives Display (hearts) ---------- */
        #lives {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px #000;
            z-index: 10;
            pointer-events: none;
            font-size: 32px;
            font-weight: bold;
        }

        /* ---------- Menu Button (bottom-right) ---------- */
        #menuBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 2px solid white;
            padding: 10px 20px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            z-index: 20;
            border-radius: 5px;
            pointer-events: auto;
        }

        /* ---------- Side Menu (settings / pause panel) ---------- */
        #sideMenu {
            position: absolute;
            top: 0;
            right: -350px;
            width: 300px;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            z-index: 100;
            padding: 15px;
            padding-top: 10px;
            box-sizing: border-box;
            transition: right 0.3s ease-out;
            display: flex;
            flex-direction: column;
            border-left: 2px solid #444;
            overflow-y: auto;
        }

        #sideMenu.open {
            right: 0;
        }

        .menu-opt {
            margin: 4px 0;
            padding: 10px;
            background: #333;
            cursor: pointer;
            border: 1px solid #555;
            text-align: center;
            border-radius: 5px;
            transition: all 0.2s;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            font-size: 14px;
        }

        .menu-opt.active {
            background: #4CAF50;
            border-color: #81C784;
            font-weight: bold;
        }

        /* ---------- Overlay Screen (start / game-over) ---------- */
        #overlayScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.45);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            color: white;
        }

        .big-btn {
            padding: 20px 40px;
            font-size: 28px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            text-align: center;
        }

        /* ---------- Bluetooth Pairing Buttons ---------- */
        .bt-btn {
            padding: 15px 30px;
            font-size: 18px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            max-width: 90vw;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            text-align: center;
        }

        .bt-btn.connected {
            background: #4CAF50;
            cursor: default;
        }

        .bt-btn.connecting {
            background: #FF9800;
        }

        .restart-btn {
            padding: 15px 30px;
            font-size: 22px;
            background: #FF9800;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            text-align: center;
        }

        /* ---------- Debug Test Buttons ---------- */
        .test-btn {
            background: #f00;
            color: white;
            border: none;
            padding: 10px;
            width: 100%;
            margin-top: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 11px;
            border-radius: 3px;
        }

        .test-btn:active {
            background: #c00;
        }

        .test-btn.secondary {
            background: #ff9800;
        }

        .test-btn.secondary:active {
            background: #e68900;
        }

        .test-btn.tertiary {
            background: #2196F3;
        }

        .test-btn.tertiary:active {
            background: #1976D2;
        }

        .test-btn.calib {
            background: #9C27B0;
        }

        .test-btn.calib:active {
            background: #7B1FA2;
        }

        .reset-score-btn {
            padding: 10px 30px;
            font-size: 16px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        /* Visual Effect Overlays */


        #speed-lines {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(255, 255, 255, 0.15) 70%, rgba(255, 255, 255, 0.3) 100%);
            transition: opacity 0.3s;
        }









        /* ---------- BPM / Heart-Rate Tracker Widget ---------- */
        #bpm-tracker {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 100px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 10px;
            border: 2px solid #ff3366;
            padding: 8px;
            z-index: 15;
            pointer-events: none;
            text-align: center;
        }

        #bpm-tracker .bpm-icon {
            font-size: 20px;
            animation: heartbeat 1s ease-in-out infinite;
        }

        #bpm-tracker .bpm-value {
            font-size: 28px;
            font-weight: bold;
            color: #ff3366;
            text-shadow: 0 0 10px #ff3366;
            font-family: 'Courier New', monospace;
        }

        #bpm-tracker .bpm-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }

        #bpm-tracker.warning {
            border-color: #ff6600;
        }

        #bpm-tracker.warning .bpm-value {
            color: #ff6600;
            text-shadow: 0 0 10px #ff6600;
        }

        #bpm-tracker.danger {
            border-color: #ff0000;
            animation: pulse-danger 0.5s ease-in-out infinite;
        }

        #bpm-tracker.danger .bpm-value {
            color: #ff0000;
            text-shadow: 0 0 15px #ff0000;
        }

        @keyframes heartbeat {

            0%,
            100% {
                transform: scale(1);
            }

            15% {
                transform: scale(1.2);
            }

            30% {
                transform: scale(1);
            }

            45% {
                transform: scale(1.1);
            }

            60% {
                transform: scale(1);
            }
        }

        @keyframes pulse-danger {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            }

            50% {
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            }
        }
    </style>

    <!-- ======================== EXTERNAL LIBRARIES ======================== -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> <!-- 3D engine -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <!-- JSX transpiler -->
</head>

<body>

    <!-- Loading overlay (hidden once background texture loads) -->
    <div id="loader">Loading Assets...</div>

    <!-- Speed-lines visual effect (opacity controlled by JS) -->
    <div id="speed-lines"></div>

    <!-- Heart-rate BPM tracker widget (shown during gameplay) -->
    <div id="bpm-tracker" style="display: none;">
        <span class="bpm-icon">‚ù§Ô∏è</span>
        <span class="bpm-value" id="bpm-value">--</span>
        <span class="bpm-label">BPM</span>
    </div>

    <!-- React root container -->
    <div id="root"></div>

    <!-- ======================== GAME LOGIC (React + Three.js) ======================== -->
    <script type="text/babel">
        const { useEffect, useRef, useState } = React;

        // ‚îÄ‚îÄ Debug HUD Updaters ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Called from BLE event handlers to update the on-screen debug panel.
        window.updateDebug = (status, x, action) => {
            const stEl = document.getElementById('st');
            if (status && stEl) {
                stEl.innerText = status;
                stEl.className = status === 'CONNECTED' ? 'status-connected' : status === 'CONNECTING...' ? 'status-connecting' : 'status-disconnected';
            }
            if (x !== null && x !== undefined) {
                const txEl = document.getElementById('tx');
                if (txEl) txEl.innerText = x.toFixed(2);
            }
            if (action) {
                const actEl = document.getElementById('act');
                if (actEl) actEl.innerText = action;
            }
        };
        window.updateThrottleDebug = (status, throttleVal) => {
            const stEl = document.getElementById('thst');
            if (status && stEl) {
                stEl.innerText = status;
                stEl.className = status === 'CONNECTED' ? 'status-connected' : status === 'CONNECTING...' ? 'status-connecting' : 'status-disconnected';
            }
            if (throttleVal !== null && throttleVal !== undefined) {
                const thEl = document.getElementById('thv');
                if (thEl) thEl.innerText = throttleVal.toFixed(2);
            }
        };

        // Update BPM display widget and apply warning/danger CSS classes.
        window.updateBpmDisplay = (bpm) => {
            const bpmValEl = document.getElementById('bpm-value');
            const bpmTracker = document.getElementById('bpm-tracker');
            if (bpmValEl) bpmValEl.innerText = bpm;
            if (bpmTracker) {
                bpmTracker.classList.remove('warning', 'danger');
                if (bpm > 150) {
                    bpmTracker.classList.add('danger');
                } else if (bpm > 120) {
                    bpmTracker.classList.add('warning');
                }
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  BlockyCarGame ‚Äî Main React Component
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const BlockyCarGame = () => {
            const mountRef = useRef(null);

            // ‚îÄ‚îÄ React State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const [gameStarted, setGameStarted] = useState(false);
            const [gameOver, setGameOver] = useState(false);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [lives, setLives] = useState(3);
            const [newRecord, setNewRecord] = useState(false);
            const [menuOpen, setMenuOpen] = useState(false);
            const [uiDifficulty, setUiDifficulty] = useState('Progressive');
            // ‚îÄ‚îÄ Settings (persisted to localStorage) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const [volume, setVolume] = useState(() => { const saved = localStorage.getItem('blockyRacerVolume'); return saved ? parseFloat(saved) : 0.5; });
            const [sensitivity, setSensitivity] = useState(() => { const saved = localStorage.getItem('blockyRacerSensitivity'); return saved ? parseFloat(saved) : 0.5; });
            const [language, setLanguage] = useState(localStorage.getItem('blockyRacerLang') || 'en');
            const volumeRef = useRef(0.5);
            const sensitivityRef = useRef(0.5);

            // ‚îÄ‚îÄ BLE Connection State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const [btConnected, setBtConnected] = useState(false);       // Steering controller
            const [btConnecting, setBtConnecting] = useState(false);
            const [thBtConnected, setThBtConnected] = useState(false);   // Throttle controller
            const [thBtConnecting, setThBtConnecting] = useState(false);

            const [calibrated, setCalibrated] = useState(false);         // Tilt calibration feedback

            // ‚îÄ‚îÄ Translations (English / Chinese) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const translations = {
                en: {
                    score: 'Score', highScore: 'High Score', difficulty: 'Difficulty',
                    paused: 'PAUSED', settings: 'Settings', volume: 'Volume',
                    sensitivity: 'Pedal Sensitivity', difficultyMode: 'Difficulty Mode',
                    progressive: 'Progressive', easy: 'Easy', medium: 'Medium',
                    hard: 'Hard', challenging: 'Challenging', resume: 'RESUME GAME',
                    title: 'CAR ADVENTURE', resetScore: 'Reset High Score',
                    pairSteering: 'HAND CONTROLLER', pairThrottle: 'FOOT PEDAL',
                    connecting: 'CONNECTING...', paired: 'PAIRED',
                    startEngine: 'START ENGINE', crashed: 'CRASHED!',
                    newRecord: 'NEW HIGH SCORE!',
                    pressRestart: 'Press SPACE or button to restart',
                    playAgain: 'PLAY AGAIN', mainMenu: 'MAIN MENU',
                    language: 'Language', menu: 'MENU', fixed: 'Fixed'
                },
                zh: {
                    score: 'ÂàÜÊï∞', highScore: 'ÊúÄÈ´òÂàÜ', difficulty: 'ÈöæÂ∫¶',
                    paused: 'ÊöÇÂÅú', settings: 'ËÆæÁΩÆ', volume: 'Èü≥Èáè',
                    sensitivity: 'Ë∏èÊùøÁÅµÊïèÂ∫¶', difficultyMode: 'ÈöæÂ∫¶Ê®°Âºè',
                    progressive: 'ÂèòÂºè', easy: 'ÁÆÄÂçï', medium: '‰∏≠Á≠â',
                    hard: 'Èöæ', challenging: 'ÊåëÊàò', resume: 'ÁªßÁª≠Ê∏∏Êàè',
                    title: 'Ê±ΩËΩ¶ÂÜíÈô©', resetScore: 'ÈáçÁΩÆÊúÄÈ´òÂàÜ',
                    pairSteering: 'ÊâãÊéßÂô®', pairThrottle: 'ËÑöË∏èÊùø',
                    connecting: 'ËøûÊé•‰∏≠...', paired: 'Â∑≤ÈÖçÂØπ',
                    startEngine: 'ÂºÄÂßãÊ∏∏Êàè', crashed: 'ÊíûËΩ¶‰∫ÜÔºÅ',
                    newRecord: 'Êñ∞Á∫™ÂΩïÔºÅ',
                    pressRestart: 'ÊåâÁ©∫Ê†ºÈîÆÊàñÊåâÈíÆÈáçÊñ∞ÂºÄÂßã',
                    playAgain: 'ÂÜçÁé©‰∏ÄÊ¨°', mainMenu: '‰∏ªÈ°µ',
                    language: 'ËØ≠Ë®Ä', menu: 'ËÆæÁΩÆ', fixed: 'ÂÆöÂºè'
                }
            };
            const t = (key) => translations[language]?.[key] || translations.en[key] || key;
            const changeLanguage = (lang) => { setLanguage(lang); localStorage.setItem('blockyRacerLang', lang); };

            // ... (omitted lines) ...

            // ‚îÄ‚îÄ Refs for BLE packet counters and vibration cooldown ‚îÄ‚îÄ
            const vibeTimeoutRef = useRef(null);
            const packetCountRef = useRef(0);
            const vibeCountRef = useRef(0);
            const throttlePacketCountRef = useRef(0);

            // ‚îÄ‚îÄ BLE device references ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // Steering controller (hand controller with tilt sensor, vibration, button, BPM)
            const btRef = useRef({
                device: null, server: null,
                sensorChar: null, vibeChar: null, buttonChar: null,
                tilt: 0, isConnecting: false
            });
            const tiltOffsetRef = useRef(0); // Software calibration offset for tilt sensor

            // Throttle controller (foot pedal with rotary encoder)
            const throttleBtRef = useRef({
                device: null, server: null, throttleChar: null,
                throttle: 0.0, isConnecting: false
            });

            // ‚îÄ‚îÄ Audio refs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const audioCtxRef = useRef(null);
            const musicRef = useRef(null);

            // ‚îÄ‚îÄ Game state (mutable ref for use inside animation loop) ‚îÄ‚îÄ
            const gameStateRef = useRef({
                isGameOver: false, isPaused: false,
                score: 0, lives: 3,
                movingTime: 0, totalDistance: 0,
                gridRows: [], opponents: [],
                clouds: [], birds: [],
                difficulty: 'Progressive',
                gameStarted: false,
                sparkParticles: [],
                needsReset: false
            });

            // ‚îÄ‚îÄ BLE Service & Characteristic UUIDs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // Steering controller (hand controller)
            const SERVICE_UUID = "19b10000-e8f2-537e-4f6c-d104768a1214";
            const SENSOR_CHAR_UUID = "19b10001-e8f2-537e-4f6c-d104768a1214";  // Tilt angle (float32)
            const VIBE_CHAR_UUID = "19b10002-e8f2-537e-4f6c-d104768a1214";  // Vibration motor
            const BUTTON_CHAR_UUID = "19b10003-e8f2-537e-4f6c-d104768a1214";  // Physical button
            const BPM_CHAR_UUID = "19b10004-e8f2-537e-4f6c-d104768a1214";  // Heart rate (MAX30102)

            // Throttle controller (foot pedal ‚Äî matches Bike.ino)
            const THROTTLE_SERVICE_UUID = "19b20000-e8f2-537e-4f6c-d104768a1214";
            const THROTTLE_CHAR_UUID = "19b20001-e8f2-537e-4f6c-d104768a1214";  // Speed (float32)

            // Load persisted high score on mount
            useEffect(() => { const saved = localStorage.getItem('blockyRacerHighScore'); if (saved) setHighScore(parseInt(saved)); }, []);

            useEffect(() => {
                volumeRef.current = volume;
                if (musicRef.current) musicRef.current.volume = volume;
                localStorage.setItem('blockyRacerVolume', volume.toString());
            }, [volume]);

            useEffect(() => {
                sensitivityRef.current = sensitivity;
                localStorage.setItem('blockyRacerSensitivity', sensitivity.toString());
            }, [sensitivity]);
            const updateVibeStatus = (status, isSuccess) => { const statusEl = document.getElementById('vibeStatus'); if (statusEl) { statusEl.innerText = status; statusEl.className = isSuccess ? 'vibe-success' : 'vibe-fail'; } };
            const updateVibeCount = () => { vibeCountRef.current++; const countEl = document.getElementById('vibeCount'); if (countEl) countEl.innerText = vibeCountRef.current; };
            const updateLastError = (error) => { const errorEl = document.getElementById('lastError'); if (errorEl) errorEl.innerText = error; };
            // ‚îÄ‚îÄ BLE Disconnect Handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // Called when a BLE device is unexpectedly disconnected.
            const onDisconnected = () => { console.log("‚ö†Ô∏è DEVICE DISCONNECTED"); setBtConnected(false); setBtConnecting(false); if (btRef.current) { btRef.current.tilt = 0; btRef.current.device = null; btRef.current.server = null; btRef.current.sensorChar = null; btRef.current.vibeChar = null; btRef.current.buttonChar = null; btRef.current.isConnecting = false; } window.updateDebug("DISCONNECTED", 0, "---"); updateVibeStatus("Disconnected", false); };
            const onThrottleDisconnected = () => { console.log("‚ö†Ô∏è THROTTLE DEVICE DISCONNECTED"); setThBtConnected(false); setThBtConnecting(false); if (throttleBtRef.current) { throttleBtRef.current.throttle = 0.0; throttleBtRef.current.device = null; throttleBtRef.current.server = null; throttleBtRef.current.throttleChar = null; throttleBtRef.current.isConnecting = false; } window.updateThrottleDebug("DISCONNECTED", 0.0); };

            // ‚îÄ‚îÄ connectBluetooth() ‚Äî Hand Controller (Steering) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // Connects to the steering BLE device, subscribes to tilt sensor,
            // button, vibration, and optional BPM characteristics.
            const connectBluetooth = async (isReconnect = false) => {
                if (btRef.current.isConnecting) { console.log("‚è∏Ô∏è Connection in progress"); return; }
                try {
                    btRef.current.isConnecting = true; setBtConnecting(true); window.updateDebug("CONNECTING...", null, null);
                    const device = isReconnect && btRef.current.device ? btRef.current.device : await navigator.bluetooth.requestDevice({ filters: [{ services: [SERVICE_UUID] }], optionalServices: [SERVICE_UUID] });
                    console.log("‚úì Device:", device.name); device.addEventListener('gattserverdisconnected', onDisconnected);
                    let server = null; let service = null;
                    for (let attempt = 1; attempt <= 3; attempt++) {
                        try {
                            console.log(`GATT connect attempt ${attempt}/3`);
                            if (!device.gatt.connected) { server = await device.gatt.connect(); } else { server = device.gatt; }
                            await new Promise(resolve => setTimeout(resolve, 300 * attempt));
                            service = await server.getPrimaryService(SERVICE_UUID);
                            break;
                        } catch (e) {
                            console.warn(`Attempt ${attempt} failed:`, e.message);
                            if (attempt === 3) throw e;
                            try { device.gatt.disconnect(); } catch (_) { }
                            await new Promise(resolve => setTimeout(resolve, 500 * attempt));
                        }
                    }
                    const sensorChar = await service.getCharacteristic(SENSOR_CHAR_UUID); await sensorChar.startNotifications();
                    sensorChar.addEventListener('characteristicvaluechanged', (event) => { try { const raw = event.target.value.getFloat32(0, true); if (!isNaN(raw) && isFinite(raw)) { const val = raw - tiltOffsetRef.current; btRef.current.tilt = val; packetCountRef.current++; const rcvEl = document.getElementById('rcv'); if (rcvEl) rcvEl.innerText = packetCountRef.current; let action = "CENTER"; if (val >= 2.8) action = "RIGHT ‚û°Ô∏è"; else if (val <= -2.8) action = "LEFT ‚¨ÖÔ∏è"; window.updateDebug(null, val, action); } } catch (err) { console.error("Sensor data error:", err); } });
                    const vibeChar = await service.getCharacteristic(VIBE_CHAR_UUID);
                    const buttonChar = await service.getCharacteristic(BUTTON_CHAR_UUID); await buttonChar.startNotifications();
                    buttonChar.addEventListener('characteristicvaluechanged', (event) => { const val = event.target.value.getUint8(0); if (val === 1) { console.log("üîò Button pressed - simulating SPACE!"); const spaceEvent = new KeyboardEvent('keydown', { code: 'Space', key: ' ', keyCode: 32, bubbles: true }); window.dispatchEvent(spaceEvent); } });
                    // BPM/Heart Rate from MAX30102
                    let bpmChar = null;
                    try {
                        bpmChar = await service.getCharacteristic(BPM_CHAR_UUID);
                        await bpmChar.startNotifications();
                        bpmChar.addEventListener('characteristicvaluechanged', (event) => {
                            try {
                                const bpm = event.target.value.getUint8(0);
                                if (bpm > 0 && bpm < 250) {
                                    btRef.current.bpm = bpm;
                                    window.updateBpmDisplay(bpm);
                                }
                            } catch (err) { console.error("BPM data error:", err); }
                        });
                        console.log("‚úÖ BPM characteristic connected");
                    } catch (e) { console.log("‚ö†Ô∏è BPM characteristic not available:", e.message); }
                    btRef.current = { device, server, sensorChar, vibeChar, buttonChar, bpmChar, tilt: 0, bpm: 0, isConnecting: false };
                    setBtConnected(true); setBtConnecting(false); window.updateDebug("CONNECTED", 0, "CENTER"); updateVibeStatus("Ready", true); console.log("‚úÖ Connected!");
                } catch (error) { console.error("‚ùå Connection error:", error); btRef.current.isConnecting = false; setBtConnecting(false); setBtConnected(false); window.updateDebug("ERROR", null, null); updateLastError(error.message); alert(`Connection Failed: ${error.message}`); }
            };

            // ‚îÄ‚îÄ connectThrottleBluetooth() ‚Äî Foot Pedal (Throttle) ‚îÄ‚îÄ‚îÄ‚îÄ
            // Connects to the throttle BLE device (Bike.ino) and subscribes
            // to the float32 speed characteristic.
            const connectThrottleBluetooth = async (isReconnect = false) => {
                if (throttleBtRef.current.isConnecting) { console.log("‚è∏Ô∏è Throttle connection in progress"); return; }
                try {
                    throttleBtRef.current.isConnecting = true; setThBtConnecting(true); window.updateThrottleDebug("CONNECTING...", null);
                    const device = isReconnect && throttleBtRef.current.device ? throttleBtRef.current.device : await navigator.bluetooth.requestDevice({ filters: [{ services: [THROTTLE_SERVICE_UUID] }], optionalServices: [THROTTLE_SERVICE_UUID] });
                    console.log("‚úì Throttle Device:", device.name); device.addEventListener('gattserverdisconnected', onThrottleDisconnected);
                    const server = await device.gatt.connect(); await new Promise(resolve => setTimeout(resolve, 200));
                    const service = await server.getPrimaryService(THROTTLE_SERVICE_UUID);
                    const throttleChar = await service.getCharacteristic(THROTTLE_CHAR_UUID); await throttleChar.startNotifications();
                    throttleChar.addEventListener('characteristicvaluechanged', (event) => { try { const val = event.target.value.getFloat32(0, true); if (!isNaN(val) && isFinite(val)) { const clamped = Math.max(0, Math.min(1, val)); throttleBtRef.current.throttle = val; throttlePacketCountRef.current++; const thrcvEl = document.getElementById('thrcv'); if (thrcvEl) thrcvEl.innerText = throttlePacketCountRef.current; window.updateThrottleDebug(null, clamped); } } catch (err) { console.error("Throttle data error:", err); } });
                    throttleBtRef.current = { device, server, throttleChar, throttle: 0.0, isConnecting: false };
                    setThBtConnected(true); setThBtConnecting(false); window.updateThrottleDebug("CONNECTED", 0.0); console.log("‚úÖ Throttle connected!");
                } catch (error) { console.error("‚ùå Throttle connection error:", error); throttleBtRef.current.isConnecting = false; setThBtConnecting(false); setThBtConnected(false); window.updateThrottleDebug("ERROR", null); alert(`Throttle Connection Failed: ${error.message}`); }
            };

            // === CALIBRATION & RECONNECT WINDOW FUNCTIONS ===
            // These are exposed on `window` so they can be called from
            // debug buttons and the HUD calibrate button.
            window.calibrateTilt = () => {
                // Software calibration: store offset
                tiltOffsetRef.current = btRef.current.tilt + tiltOffsetRef.current;
                btRef.current.tilt = 0;
                const txEl = document.getElementById('tx');
                if (txEl) txEl.innerText = '0.00';
                // Hardware calibration: send calibrate command to BLE device
                if (btRef.current.vibeChar) {
                    const data = new Uint8Array([67]); // 'C' for calibrate
                    btRef.current.vibeChar.writeValueWithoutResponse(data)
                        .then(() => console.log('‚úÖ Hardware calibration sent'))
                        .catch(err => console.error('‚ùå Hardware calibration failed:', err));
                }
                console.log('‚úÖ Tilt calibrated! Offset:', tiltOffsetRef.current);
            };
            window.reconnectSteering = () => { connectBluetooth(true); };
            window.reconnectThrottle = () => { connectThrottleBluetooth(true); };
            // ‚îÄ‚îÄ Vibration Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const sendCalibration = async () => { if (!btRef.current.vibeChar) { alert("Not connected!"); return; } try { const data = new Uint8Array([67]); await btRef.current.vibeChar.writeValueWithoutResponse(data); console.log("‚úÖ Calibration sent"); updateVibeStatus("Calibrating...", true); } catch (err) { console.error("‚ùå Calibration failed:", err); updateVibeStatus("FAIL: " + err.message, false); } };
            const sendVibration = async (fromCrash = false, duration = 400) => { if (!btRef.current.vibeChar) { console.error("‚ùå Not connected"); return; } if (!fromCrash && vibeTimeoutRef.current) { return; } try { const data = new Uint8Array([1]); await btRef.current.vibeChar.writeValueWithoutResponse(data); console.log(`‚úÖ Vibe sent (${duration}ms)`); updateVibeStatus("Sent!", true); updateVibeCount(); updateLastError("None"); if (!fromCrash) { vibeTimeoutRef.current = setTimeout(() => { vibeTimeoutRef.current = null; }, 1000); } } catch (err) { console.error("‚ùå Vibe failed:", err); updateVibeStatus("FAIL: " + err.message, false); updateLastError(err.message); } };
            const resetHighScore = () => { if (confirm("Reset high score to 0?")) { localStorage.setItem('blockyRacerHighScore', '0'); setHighScore(0); alert("High score reset!"); } };

            // ‚îÄ‚îÄ Keyboard & Button Event Bindings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            useEffect(() => { const calibBtn = document.getElementById('calibBtn'); const testBtn = document.getElementById('testVibeBtn'); const reconnectBtn = document.getElementById('reconnectBtn'); const reconnectThrottleBtn = document.getElementById('reconnectThrottleBtn'); if (calibBtn) calibBtn.onclick = sendCalibration; if (testBtn) testBtn.onclick = () => sendVibration(false); if (reconnectBtn) reconnectBtn.onclick = () => connectBluetooth(false); if (reconnectThrottleBtn) reconnectThrottleBtn.onclick = () => connectThrottleBluetooth(false); const handleKeyPress = (e) => { if (e.code === 'Space' && gameStateRef.current.isGameOver) { e.preventDefault(); triggerRestart(); } }; window.addEventListener('keydown', handleKeyPress); return () => window.removeEventListener('keydown', handleKeyPress); }, []);

            // ‚îÄ‚îÄ Menu / Difficulty / Restart Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const toggleMenu = () => { if (gameOver || !gameStarted) return; setMenuOpen(!menuOpen); gameStateRef.current.isPaused = !menuOpen; };
            const changeDifficulty = (mode) => { gameStateRef.current.difficulty = mode; setUiDifficulty(mode); };
            const triggerRestart = () => { console.log("üîÑ Restarting..."); setGameOver(false); setScore(0); setLives(3); setNewRecord(false); setMenuOpen(false); setGameStarted(true); const ref = gameStateRef.current; ref.isGameOver = false; ref.isPaused = false; ref.score = 0; ref.lives = 3; ref.movingTime = 0; ref.totalDistance = 0; ref.gameStarted = true; ref.needsReset = true; ref.opponents.forEach(o => { if (o.mesh && o.mesh.parent) o.mesh.parent.remove(o.mesh); }); ref.opponents = []; for (let i = 0; i < ref.gridRows.length; i++) { ref.gridRows[i].z = -350 + (i * 15); ref.gridRows[i].mesh.position.z = ref.gridRows[i].z; ref.gridRows[i].mesh.position.x = 0; ref.gridRows[i].mesh.rotation.y = 0; updateRowVisuals(ref.gridRows[i], true); } };
            const updateRowVisuals = (rowObj, isRural) => {
                rowObj.buildL.visible = false;
                rowObj.buildR.visible = false;

                // Guardrails - more common in urban, occasional in rural
                if (rowObj.guardL) rowObj.guardL.visible = !isRural && Math.random() > 0.3;
                if (rowObj.guardR) rowObj.guardR.visible = !isRural && Math.random() > 0.3;

                // Road signs
                if (rowObj.signL) rowObj.signL.visible = Math.random() > 0.2;
                if (rowObj.signR) rowObj.signR.visible = Math.random() > 0.3;

                if (isRural) {
                    // Rural: scattered trees
                    rowObj.treeInnerL.visible = Math.random() > 0.7;
                    rowObj.treeInnerR.visible = Math.random() > 0.7;
                    rowObj.treeMidL.visible = Math.random() > 0.65;
                    rowObj.treeMidR.visible = Math.random() > 0.65;
                    rowObj.treeOuterL.visible = Math.random() > 0.7;
                    rowObj.treeOuterR.visible = Math.random() > 0.7;
                    if (Math.random() > 0.85) {
                        setBuildingType(rowObj.buildL, 'house');
                        rowObj.buildL.visible = true;
                        rowObj.treeMidL.visible = false;
                    }
                    if (Math.random() > 0.85) {
                        setBuildingType(rowObj.buildR, 'house');
                        rowObj.buildR.visible = true;
                        rowObj.treeMidR.visible = false;
                    }
                } else {
                    // City: trees near road, buildings further out
                    rowObj.treeInnerL.visible = Math.random() > 0.4;
                    rowObj.treeInnerR.visible = Math.random() > 0.4;
                    rowObj.treeMidL.visible = false;
                    rowObj.treeMidR.visible = false;
                    rowObj.treeOuterL.visible = false;
                    rowObj.treeOuterR.visible = false;
                    const rowIndex = gameStateRef.current.gridRows.indexOf(rowObj);
                    if (rowIndex % 2 === 0) {
                        if (Math.random() > 0.4) {
                            setBuildingType(rowObj.buildL, 'random');
                            rowObj.buildL.visible = true;
                        }
                        if (Math.random() > 0.4) {
                            setBuildingType(rowObj.buildR, 'random');
                            rowObj.buildR.visible = true;
                        }
                    }
                }
            };

            // ‚îÄ‚îÄ Visual Effects Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // setBuildingType: Show a specific building variant inside a multi-building group.
            const setBuildingType = (group, type) => { group.children.forEach(c => c.visible = false); let idx = 0; if (type === 'house') idx = 0; else { const choices = [3, 4, 5]; idx = choices[Math.floor(Math.random() * choices.length)]; } if (idx < group.children.length) group.children[idx].visible = true; };

            // Blink player car on collision (disappear/reappear every 0.25s for 1 second)
            const hidePlayerCar = (playerCarMesh) => {
                if (!playerCarMesh) return;
                let blinkCount = 0;
                const blinkInterval = setInterval(() => {
                    playerCarMesh.visible = !playerCarMesh.visible;
                    blinkCount++;
                    if (blinkCount >= 4) { // 4 toggles = 1 second (4 x 0.25s)
                        clearInterval(blinkInterval);
                        playerCarMesh.visible = true;
                    }
                }, 250);
            };
            // Blink any mesh immediately (for enemy flash on collision)
            const blinkMesh = (mesh) => {
                if (!mesh) return;
                mesh.visible = false; // Start hidden immediately
                let blinkCount = 1;
                const blinkInterval = setInterval(() => {
                    mesh.visible = !mesh.visible;
                    blinkCount++;
                    if (blinkCount >= 4) {
                        clearInterval(blinkInterval);
                        mesh.visible = true;
                    }
                }, 250);
            };
            const updateSpeedLines = (speed) => {
                const el = document.getElementById('speed-lines');
                if (el) el.style.opacity = Math.min(1, Math.max(0, (speed - 0.8) * 2));
            };

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            //  Three.js Scene Setup (useEffect ‚Äî runs once on mount)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            useEffect(() => {
                if (!mountRef.current) return;

                // ‚îÄ‚îÄ Renderer & Scene ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);      // Sky blue
                scene.fog = new THREE.Fog(0xaaccff, 10, 280);      // Distance fog
                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                mountRef.current.appendChild(renderer.domElement);

                // ‚îÄ‚îÄ Sky Background Texture ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                new THREE.TextureLoader().load('https://images.unsplash.com/photo-1513002749550-c59d786b8e6c?q=80&w=2560&auto=format&fit=crop', (t) => {
                    scene.background = t;
                    const l = document.getElementById('loader'); if (l) { l.style.opacity = 0; setTimeout(() => l.style.display = 'none', 500); }
                });

                // ‚îÄ‚îÄ Lighting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
                dirLight.position.set(100, 150, 50);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 512;
                dirLight.shadow.mapSize.height = 512;
                dirLight.shadow.camera.left = -200;
                dirLight.shadow.camera.right = 200;
                dirLight.shadow.camera.top = 200;
                dirLight.shadow.camera.bottom = -200;
                scene.add(dirLight);

                // ‚îÄ‚îÄ Spark Particle Pool (collision sparks) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const sparkMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
                for (let i = 0; i < 30; i++) {
                    const spark = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.15), sparkMat.clone());
                    spark.visible = false; scene.add(spark);
                    gameStateRef.current.sparkParticles.push({ mesh: spark, vx: 0, vy: 0, vz: 0, life: 0, active: false });
                }
                const spawnSparks = (x, y, z) => {
                    for (let i = 0; i < 15; i++) {
                        const p = gameStateRef.current.sparkParticles.find(s => !s.active);
                        if (p) {
                            p.mesh.position.set(x + (Math.random() - 0.5) * 2, y + Math.random(), z);
                            p.mesh.visible = true; p.active = true; p.life = 20 + Math.random() * 15;
                            p.vx = (Math.random() - 0.5) * 0.4; p.vy = 0.1 + Math.random() * 0.2; p.vz = Math.random() * 0.3;
                            p.mesh.material.color.setHex([0xff6600, 0xffaa00, 0xffff00][Math.floor(Math.random() * 3)]);
                        }
                    }
                };

                // ‚îÄ‚îÄ Window Texture Generator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Creates a procedural canvas texture simulating building
                // windows with randomized lit/dark panes.
                const createModernWindowTexture = (density) => {
                    const size = 256;
                    const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#999999'; ctx.fillRect(0, 0, size, size); // Concrete base

                    // Scale grid based on density more aggressively
                    const cols = Math.max(1, Math.floor(density * 10));
                    const rows = Math.max(1, Math.floor(density * 20));

                    if (cols === 0 || rows === 0) return new THREE.CanvasTexture(canvas); // Empty concrete

                    const padX = size / cols;
                    const padY = size / rows;
                    const wW = padX * 0.6; // Window Width
                    const wH = padY * 0.7; // Window Height

                    for (let y = 0; y < rows; y++) {
                        for (let x = 0; x < cols; x++) {
                            // Randomize window existence: Lower density = lower chance per cell too
                            if (Math.random() > 0.5) {
                                const isLit = Math.random() > 0.3;
                                ctx.fillStyle = isLit ? (Math.random() > 0.7 ? '#ffffee' : '#ccddff') : '#223344';
                                ctx.fillRect(x * padX + (padX - wW) / 2, y * padY + (padY - wH) / 2, wW, wH);
                            }
                        }
                    }
                    const tex = new THREE.CanvasTexture(canvas);
                    tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
                    tex.magFilter = THREE.LinearFilter; tex.minFilter = THREE.LinearFilter;
                    return tex;
                };


                // ‚îÄ‚îÄ Pre-cached Material & Texture Pools ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Avoids creating 240+ canvas draws per building by
                // sharing materials and textures across all instances.
                const colorTints = [0xcc9999, 0x99ccbb, 0xbbbb99, 0x9999cc, 0xccbb99, 0x99bbcc, 0xdd8888, 0x88dd88, 0x8888dd, 0xdddd88, 0xC4A77D, 0xB8956E, 0xA68B5B, 0xD4B896, 0xBBAA88];
                const accentColors = [0x444466, 0x664444, 0x446644, 0x556655, 0x665544, 0x445566, 0x5A4A3A, 0x6B5B4B];
                const cachedWinTextures = [0.5, 0.65, 0.8, 0.95].map(d => createModernWindowTexture(d));
                const cachedBaseTextures = [createModernWindowTexture(0.1), createModernWindowTexture(0.15)];
                const cachedConcreteMats = colorTints.map(c => new THREE.MeshLambertMaterial({ color: c }));
                const cachedAccentMats = accentColors.map(c => new THREE.MeshLambertMaterial({ color: c }));
                const cachedWinMats = cachedWinTextures.map(t => new THREE.MeshLambertMaterial({ map: t }));
                const cachedBaseMats = cachedBaseTextures.map(t => new THREE.MeshLambertMaterial({ map: t }));

                // Global shared materials (avoid recreating in loops)
                const matCache = {
                    brown: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
                    doorFrame: new THREE.MeshLambertMaterial({ color: 0x2F1810 }),
                    door: new THREE.MeshLambertMaterial({ color: 0x4A2511 }),
                    handle: new THREE.MeshLambertMaterial({ color: 0xCCAA00 }),
                    window: new THREE.MeshLambertMaterial({ color: 0x88ccff }),
                    shutter: new THREE.MeshLambertMaterial({ color: 0x2E5E4E }),
                    awning: new THREE.MeshLambertMaterial({ color: 0x663333 }),
                    pillarWhite: new THREE.MeshLambertMaterial({ color: 0xeeeeee }),
                    garageDoor: new THREE.MeshLambertMaterial({ color: 0x555555 }),
                    dark222: new THREE.MeshLambertMaterial({ color: 0x222222 }),
                    dark333: new THREE.MeshLambertMaterial({ color: 0x333333 }),
                    dark444: new THREE.MeshLambertMaterial({ color: 0x444444 }),
                    grey555: new THREE.MeshLambertMaterial({ color: 0x555555 }),
                    grey666: new THREE.MeshLambertMaterial({ color: 0x666666 }),
                    grey777: new THREE.MeshLambertMaterial({ color: 0x777777 }),
                    grey888: new THREE.MeshLambertMaterial({ color: 0x888888 }),
                    greyAAA: new THREE.MeshLambertMaterial({ color: 0xaaaaaa }),
                    greyCCC: new THREE.MeshLambertMaterial({ color: 0xcccccc }),
                    grey4a: new THREE.MeshLambertMaterial({ color: 0x4a4a4a }),
                    grey5a: new THREE.MeshLambertMaterial({ color: 0x5a5a5a }),
                    entrance: new THREE.MeshLambertMaterial({ color: 0x88aacc, transparent: true, opacity: 0.7 }),
                    glassRail: new THREE.MeshLambertMaterial({ color: 0x88ccdd, transparent: true, opacity: 0.5 }),
                    bridgeGlass: new THREE.MeshLambertMaterial({ color: 0x88ccdd, transparent: true, opacity: 0.6 }),
                    lobbyDoor: new THREE.MeshLambertMaterial({ color: 0x88aacc, transparent: true, opacity: 0.6 }),
                    glass: new THREE.MeshLambertMaterial({ color: 0x00CED1, transparent: true, opacity: 0.8 }),
                    canopyGlass: new THREE.MeshLambertMaterial({ color: 0x88ddee, transparent: true, opacity: 0.5 }),
                    redLight: new THREE.MeshBasicMaterial({ color: 0xff0000 }),
                    cyanLed: new THREE.MeshBasicMaterial({ color: 0x00ffff }),
                    yellow: new THREE.MeshLambertMaterial({ color: 0xffff00 }),
                    redFlag: new THREE.MeshLambertMaterial({ color: 0xff0000, side: THREE.DoubleSide }),
                    crane: new THREE.MeshLambertMaterial({ color: 0xffaa00 }),
                    blue06: new THREE.MeshLambertMaterial({ color: 0x0066cc }),
                    winBlue: new THREE.MeshLambertMaterial({ color: 0x88aacc }),
                    chimneyDark: new THREE.MeshLambertMaterial({ color: 0x333333 }),
                    trunk: new THREE.MeshLambertMaterial({ color: 0x5C4033 }),
                };

                // ‚îÄ‚îÄ Shared Geometries (geometry caching) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Avoids recreating identical BoxGeometry, CylinderGeometry,
                // and SphereGeometry objects in loops.
                const geoCache = {};
                const getBoxGeo = (w, h, d) => {
                    const key = `b${w}_${h}_${d}`;
                    if (!geoCache[key]) geoCache[key] = new THREE.BoxGeometry(w, h, d);
                    return geoCache[key];
                };
                const getCylGeo = (rt, rb, h, seg) => {
                    const key = `c${rt}_${rb}_${h}_${seg}`;
                    if (!geoCache[key]) geoCache[key] = new THREE.CylinderGeometry(rt, rb, h, seg);
                    return geoCache[key];
                };
                const getSphGeo = (r, ws, hs) => {
                    const key = `s${r}_${ws}_${hs}`;
                    if (!geoCache[key]) geoCache[key] = new THREE.SphereGeometry(r, ws, hs);
                    return geoCache[key];
                };

                // ‚îÄ‚îÄ createMultiBuilding() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Creates a group with 6 building variants (0‚Äì5):
                //   0 = House,  1 = Stepped Tower,  2 = Linear High-Rise,
                //   3 = Modern Twin,  4 = Glass Tower,  5 = Factory.
                // Only one variant is visible at a time.
                const createMultiBuilding = () => {
                    const root = new THREE.Group();
                    const concreteMat = cachedConcreteMats[Math.floor(Math.random() * cachedConcreteMats.length)];
                    const darkMat = cachedAccentMats[Math.floor(Math.random() * cachedAccentMats.length)];
                    const buildingMat = cachedWinMats[Math.floor(Math.random() * cachedWinMats.length)];
                    const baseMat = cachedBaseMats[Math.floor(Math.random() * cachedBaseMats.length)];

                    // 0. House - Enhanced with more details
                    const g0 = new THREE.Group();
                    const h0 = new THREE.Mesh(getBoxGeo(8, 6, 8), concreteMat); h0.position.y = 3; h0.castShadow = true; g0.add(h0);
                    const r0 = new THREE.Mesh(new THREE.ConeGeometry(6, 4, 4), darkMat); r0.position.y = 8; r0.rotation.y = Math.PI / 4; g0.add(r0);
                    const chimney0 = new THREE.Mesh(getBoxGeo(1, 3, 1), matCache.brown);
                    chimney0.position.set(2.5, 8, -2); g0.add(chimney0);
                    const doorFrame = new THREE.Mesh(getBoxGeo(2, 3, 0.1), matCache.doorFrame);
                    doorFrame.position.set(0, 1.5, 4.05); g0.add(doorFrame);
                    const door = new THREE.Mesh(getBoxGeo(1.5, 2.5, 0.2), matCache.door);
                    door.position.set(0, 1.25, 4.1); g0.add(door);
                    const handle = new THREE.Mesh(getSphGeo(0.1, 4, 4), matCache.handle);
                    handle.position.set(0.5, 1.3, 4.25); g0.add(handle);
                    const winGeo = getBoxGeo(1.8, 1.8, 0.2);
                    const w1 = new THREE.Mesh(winGeo, matCache.window); w1.position.set(-2.5, 3.5, 4.1); g0.add(w1);
                    const w2 = new THREE.Mesh(winGeo, matCache.window); w2.position.set(2.5, 3.5, 4.1); g0.add(w2);
                    const shutterGeo = getBoxGeo(0.4, 1.8, 0.1);
                    [-2.5, 2.5].forEach(x => {
                        const sL = new THREE.Mesh(shutterGeo, matCache.shutter); sL.position.set(x - 1.2, 3.5, 4.15); g0.add(sL);
                        const sR = new THREE.Mesh(shutterGeo, matCache.shutter); sR.position.set(x + 1.2, 3.5, 4.15); g0.add(sR);
                    });
                    const awning = new THREE.Mesh(getBoxGeo(3, 0.2, 1.5), matCache.awning);
                    awning.position.set(0, 3, 4.5); g0.add(awning);
                    [-1.2, 1.2].forEach(x => {
                        const pillar = new THREE.Mesh(getCylGeo(0.15, 0.15, 3, 6), matCache.pillarWhite);
                        pillar.position.set(x, 1.5, 5); g0.add(pillar);
                    });
                    const garage = new THREE.Mesh(getBoxGeo(5, 4, 6), concreteMat);
                    garage.position.set(-6, 2, 1); g0.add(garage);
                    const garageDoor = new THREE.Mesh(getBoxGeo(3.5, 3, 0.2), matCache.garageDoor);
                    garageDoor.position.set(-6, 1.5, 4.1); g0.add(garageDoor);
                    const fencePostGeo = getBoxGeo(0.2, 1.5, 0.2);
                    for (let i = 0; i < 8; i++) {
                        const post = new THREE.Mesh(fencePostGeo, matCache.pillarWhite);
                        post.position.set(-9 + i * 2.5, 0.75, 6); g0.add(post);
                    }
                    const fenceRail = new THREE.Mesh(getBoxGeo(18, 0.1, 0.15), matCache.pillarWhite);
                    fenceRail.position.set(-2, 1.2, 6); g0.add(fenceRail);
                    root.add(g0);

                    // 1. Stepped Tower
                    const g1 = new THREE.Group();
                    {
                        const levels = 3;
                        let w = 10, h = 10, y = 0;
                        for (let i = 0; i < levels; i++) {
                            const b = new THREE.Mesh(getBoxGeo(w, h, w), i === 0 ? baseMat : buildingMat);
                            b.position.y = y + h / 2; b.castShadow = true; g1.add(b);
                            if (i > 0) {
                                for (let side = 0; side < 2; side++) {
                                    if (Math.random() > 0.5) {
                                        const balcony = new THREE.Mesh(getBoxGeo(w * 0.3, 0.2, 1.5), matCache.grey888);
                                        const bx = side === 0 ? 0 : (w / 2 + 0.7);
                                        const bz = side === 0 ? w / 2 + 0.7 : 0;
                                        balcony.position.set(bx, y + 2, bz);
                                        if (side === 1) balcony.rotation.y = Math.PI / 2;
                                        g1.add(balcony);
                                    }
                                }
                            }
                            y += h; h *= 0.8; w *= 0.8;
                        }
                        const canopy = new THREE.Mesh(getBoxGeo(6, 0.3, 3), matCache.dark333);
                        canopy.position.set(0, 3.5, 6); g1.add(canopy);
                        const entranceDoor = new THREE.Mesh(getBoxGeo(4, 3, 0.2), matCache.entrance);
                        entranceDoor.position.set(0, 1.5, 5.1); g1.add(entranceDoor);
                        [-2.5, 2.5].forEach(x => {
                            const pillar = new THREE.Mesh(getCylGeo(0.3, 0.3, 3.5, 6), matCache.grey666);
                            pillar.position.set(x, 1.75, 6); g1.add(pillar);
                        });
                        const waterTower = new THREE.Mesh(getCylGeo(1, 1.2, 3, 6), matCache.grey5a);
                        waterTower.position.set(2, y + 1.5, -2); g1.add(waterTower);
                    }
                    root.add(g1);

                    // 2. Linear High-Rise
                    const g2 = new THREE.Group();
                    {
                        const h = 45, w = 10;
                        const core = new THREE.Mesh(getBoxGeo(w, h, w), buildingMat);
                        core.position.y = h / 2; core.castShadow = true; g2.add(core);
                        const pGeo = getBoxGeo(1, h, 1);
                        [1, -1].forEach(x => [1, -1].forEach(z => {
                            const p = new THREE.Mesh(pGeo, concreteMat);
                            p.position.set(x * w / 2, h / 2, z * w / 2); g2.add(p);
                        }));
                        // Fire escape (reduced from 8 to 4 platforms)
                        const platGeo = getBoxGeo(2.5, 0.15, 2);
                        for (let floor = 0; floor < 4; floor++) {
                            const platform = new THREE.Mesh(platGeo, matCache.dark222);
                            platform.position.set(-w / 2 - 1.2, 5 + floor * 10, 0); g2.add(platform);
                        }
                        // Balconies on front side (reduced)
                        for (let floor = 2; floor < 9; floor += 2) {
                            const balcony = new THREE.Mesh(getBoxGeo(3, 0.2, 1.5), matCache.grey666);
                            balcony.position.set(0, floor * 5, w / 2 + 0.7); g2.add(balcony);
                        }
                        // Rooftop AC units
                        const acGeo = getBoxGeo(1.5, 1, 2);
                        for (let i = 0; i < 2; i++) {
                            const ac = new THREE.Mesh(acGeo, matCache.grey888);
                            ac.position.set(-2 + i * 4, h + 0.5, -2); g2.add(ac);
                        }
                        const tank = new THREE.Mesh(getCylGeo(1.5, 1.5, 4, 8), matCache.grey4a);
                        tank.position.set(3, h + 2, 3); g2.add(tank);
                        const antenna = new THREE.Mesh(getCylGeo(0.1, 0.1, 6, 4), matCache.dark333);
                        antenna.position.set(0, h + 3, 0); g2.add(antenna);
                        const lobby = new THREE.Mesh(getBoxGeo(6, 4, 3), matCache.dark444);
                        lobby.position.set(0, 2, w / 2 + 1.5); g2.add(lobby);
                        const lobbyDoor2 = new THREE.Mesh(getBoxGeo(3, 3, 0.2), matCache.lobbyDoor);
                        lobbyDoor2.position.set(0, 1.5, w / 2 + 3.1); g2.add(lobbyDoor2);
                    }
                    root.add(g2);

                    // 3. Modern Twin with sky bridge
                    const g3 = new THREE.Group();
                    {
                        const w = 14, pH = 6;
                        const pod = new THREE.Mesh(getBoxGeo(w, pH, w), baseMat);
                        pod.position.y = pH / 2; pod.castShadow = true; g3.add(pod);
                        const t1 = new THREE.Mesh(getBoxGeo(5, 30, 5), buildingMat);
                        t1.position.set(-3, pH + 15, -3); t1.castShadow = true; g3.add(t1);
                        const t2 = new THREE.Mesh(getBoxGeo(5, 20, 5), buildingMat);
                        t2.position.set(3, pH + 10, 3); t2.castShadow = true; g3.add(t2);
                        const bridge = new THREE.Mesh(getBoxGeo(8, 2, 3), matCache.grey555);
                        bridge.position.set(0, pH + 14, 0);
                        bridge.rotation.y = Math.PI / 4; g3.add(bridge);
                        const roofDome = new THREE.Mesh(new THREE.SphereGeometry(4, 12, 6, 0, Math.PI * 2, 0, Math.PI / 2), buildingMat);
                        roofDome.position.set(0, pH, 0); g3.add(roofDome);
                        const ac = new THREE.Mesh(getBoxGeo(2, 1.5, 2), matCache.grey666);
                        ac.position.set(-3, pH + 30.75, -3); g3.add(ac);
                        const antenna3 = new THREE.Mesh(getCylGeo(0.05, 0.05, 3, 4), matCache.dark333);
                        antenna3.position.set(-3, pH + 31.5, -3); g3.add(antenna3);
                        const entrance = new THREE.Mesh(getBoxGeo(4, 3, 2), matCache.dark333);
                        entrance.position.set(0, 1.5, w / 2 + 1); g3.add(entrance);
                    }
                    root.add(g3);

                    // 4. Glass Tower
                    const g4 = new THREE.Group();
                    {
                        const gw = new THREE.Mesh(getBoxGeo(15, 30, 15), matCache.glass);
                        gw.position.y = 15; gw.castShadow = true; g4.add(gw);
                        // Floor separators (reduced from 9 to 5)
                        const sepGeo = getBoxGeo(15.2, 0.3, 15.2);
                        for (let i = 1; i < 10; i += 2) {
                            const floorSep = new THREE.Mesh(sepGeo, matCache.dark444);
                            floorSep.position.y = i * 3; g4.add(floorSep);
                        }
                        // Vertical mullions (reduced from 20 to 8 - front face only)
                        const mullionGeo = getBoxGeo(0.15, 30, 0.15);
                        for (let j = -2; j <= 2; j++) {
                            const mullion = new THREE.Mesh(mullionGeo, matCache.dark333);
                            mullion.position.set(j * 3, 15, 7.6); g4.add(mullion);
                        }
                        const plaza = new THREE.Mesh(getBoxGeo(20, 0.3, 8), matCache.grey555);
                        plaza.position.set(0, 0.15, 11); g4.add(plaza);
                        const canopy4 = new THREE.Mesh(getBoxGeo(8, 0.2, 5), matCache.canopyGlass);
                        canopy4.position.set(0, 4, 9); g4.add(canopy4);
                        const spire = new THREE.Mesh(getCylGeo(0.3, 0.5, 8, 6), matCache.grey888);
                        spire.position.set(0, 34, 0); g4.add(spire);
                        const warnLight = new THREE.Mesh(getSphGeo(0.3, 6, 6), matCache.redLight);
                        warnLight.position.set(0, 38, 0); g4.add(warnLight);
                        const crown = new THREE.Mesh(getBoxGeo(16, 1, 16), matCache.dark333);
                        crown.position.set(0, 30.5, 0); g4.add(crown);
                        const ledStrip = new THREE.Mesh(getBoxGeo(16.2, 0.15, 16.2), matCache.cyanLed);
                        ledStrip.position.set(0, 30, 0); g4.add(ledStrip);
                    }
                    root.add(g4);

                    // 5. Factory Building
                    const g5 = new THREE.Group();
                    {
                        const factoryColors = [0xCD5C5C, 0x8B4513, 0xA0522D, 0xBC8F8F, 0x696969, 0x708090, 0x8B0000, 0xB22222];
                        const factoryMat = new THREE.MeshLambertMaterial({ color: factoryColors[Math.floor(Math.random() * factoryColors.length)] });
                        const factoryBody = new THREE.Mesh(getBoxGeo(18, 14, 18), factoryMat);
                        factoryBody.position.y = 7; factoryBody.castShadow = true; g5.add(factoryBody);
                        const warehouse = new THREE.Mesh(getBoxGeo(10, 10, 12), matCache.grey666);
                        warehouse.position.set(-14, 5, 0); g5.add(warehouse);
                        const roof = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 12, 8, 1, false, 0, Math.PI), matCache.grey555);
                        roof.rotation.z = Math.PI / 2; roof.rotation.y = Math.PI / 2;
                        roof.position.set(-14, 10, 0); g5.add(roof);
                        const chimGeo = getCylGeo(1.5, 1.8, 14, 8);
                        const chimney1 = new THREE.Mesh(chimGeo, matCache.chimneyDark);
                        chimney1.position.set(-5, 19, -5); g5.add(chimney1);
                        const chimney2 = new THREE.Mesh(chimGeo, matCache.chimneyDark);
                        chimney2.position.set(5, 19, -5); g5.add(chimney2);
                        const cooling = new THREE.Mesh(getCylGeo(3, 4, 8, 8), matCache.grey777);
                        cooling.position.set(6, 18, 4); g5.add(cooling);
                        const dock = new THREE.Mesh(getBoxGeo(12, 2, 5), matCache.grey555);
                        dock.position.set(0, 1, 11.5); g5.add(dock);
                        // Roll-up doors (3 bays)
                        const doorGeo5 = getBoxGeo(3, 4, 0.2);
                        for (let i = 0; i < 3; i++) {
                            const door5 = new THREE.Mesh(doorGeo5, matCache.grey666);
                            door5.position.set(-4 + i * 4, 4, 9.1); g5.add(door5);
                        }
                        // Windows
                        const winGeo5 = getBoxGeo(1.5, 2, 0.3);
                        for (let i = 0; i < 3; i++) {
                            const win = new THREE.Mesh(winGeo5, matCache.winBlue);
                            win.position.set(-3.5 + i * 3.5, 10, 9.1); g5.add(win);
                        }
                        // Pipes
                        const pipe1 = new THREE.Mesh(getCylGeo(0.3, 0.3, 12, 6), matCache.grey888);
                        pipe1.position.set(9.2, 7, 0); g5.add(pipe1);
                        // Crane
                        const cranePostGeo = getBoxGeo(0.5, 12, 0.5);
                        const cranePost1 = new THREE.Mesh(cranePostGeo, matCache.crane);
                        cranePost1.position.set(-10, 6, -8); g5.add(cranePost1);
                        const cranePost2 = new THREE.Mesh(cranePostGeo, matCache.crane);
                        cranePost2.position.set(-10, 6, 8); g5.add(cranePost2);
                        const craneBeam = new THREE.Mesh(getBoxGeo(0.4, 0.5, 17), matCache.crane);
                        craneBeam.position.set(-10, 12, 0); g5.add(craneBeam);
                    }
                    root.add(g5);

                    // Initialize: Hide all except 0
                    root.children.forEach(c => c.visible = false);
                    root.children[0].visible = true;

                    root.scale.set(1.2, 1.2, 1.2);
                    return root;
                };
                // ‚îÄ‚îÄ Environment ‚Äî Cloud, Bird, Lamp, Signs, Trees ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

                // createCloud(): Soft grouping of dodecahedrons.
                const createCloud = () => {
                    const g = new THREE.Group();
                    const mat = new THREE.MeshLambertMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.8 });
                    const n = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < n; i++) {
                        const r = 3 + Math.random() * 2;
                        const m = new THREE.Mesh(new THREE.DodecahedronGeometry(r, 0), mat);
                        m.position.set((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3);
                        g.add(m);
                    }
                    return g;
                };

                // createBird(): Simple low-poly bird with flapping wings.
                const createBird = () => {
                    const g = new THREE.Group();
                    const colors = [0x2c2c2c, 0x8B4513, 0x1e3a5f, 0x8B0000, 0x556B2F];
                    const col = colors[Math.floor(Math.random() * colors.length)];
                    const bm = new THREE.MeshLambertMaterial({ color: col });
                    // Body
                    const body = new THREE.Mesh(new THREE.SphereGeometry(0.3, 6, 6), bm);
                    body.scale.set(1, 0.7, 1.8); g.add(body);
                    // Head
                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.18, 6, 6), bm);
                    head.position.set(0, 0.1, 0.45); g.add(head);
                    // Beak
                    const beak = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.2, 4), new THREE.MeshLambertMaterial({ color: 0xFFA500 }));
                    beak.rotation.x = -Math.PI / 2; beak.position.set(0, 0.05, 0.65); g.add(beak);
                    // Wings
                    const wg = new THREE.BoxGeometry(0.5, 0.05, 0.3);
                    const wingL = new THREE.Mesh(wg, bm); wingL.position.set(0.4, 0.05, 0); g.add(wingL); g.userData.wingL = wingL;
                    const wingR = new THREE.Mesh(wg, bm); wingR.position.set(-0.4, 0.05, 0); g.add(wingR); g.userData.wingR = wingR;
                    g.scale.set(2, 2, 2);
                    return g;
                };

                // createStreetLamp(): Pole with arm and housing (daytime only, no glow).
                const createStreetLamp = () => {
                    const g = new THREE.Group();
                    const poleMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 8, 8), poleMat);
                    pole.position.y = 4; g.add(pole);
                    const arm = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 2), poleMat);
                    arm.position.set(0, 7.8, -0.8); arm.rotation.x = 0.3; g.add(arm);
                    const housing = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.6), poleMat);
                    housing.position.set(0, 7.6, -1.5); g.add(housing);
                    const base = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 0.8), poleMat);
                    base.position.y = 0.1; g.add(base);
                    return g;
                };

                // createRoadSign(): Speed limit, warning triangle, or chevron arrow.
                const createRoadSign = (type) => {
                    const g = new THREE.Group();
                    const poleMat = new THREE.MeshLambertMaterial({ color: 0x888888 });

                    // Pole
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 4, 8), poleMat);
                    pole.position.y = 2; g.add(pole);

                    if (type === 'speed') {
                        // Speed limit sign (circular)
                        const signMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
                        const sign = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.05, 16), signMat);
                        sign.rotation.x = Math.PI / 2;
                        sign.position.set(0, 3.8, 0.1);
                        g.add(sign);
                        // Red border
                        const borderMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const border = new THREE.Mesh(new THREE.TorusGeometry(0.55, 0.08, 8, 16), borderMat);
                        border.position.set(0, 3.8, 0.15);
                        g.add(border);
                    } else if (type === 'warning') {
                        // Warning sign (triangle)
                        const shape = new THREE.Shape();
                        shape.moveTo(0, 0.7);
                        shape.lineTo(-0.6, -0.3);
                        shape.lineTo(0.6, -0.3);
                        shape.lineTo(0, 0.7);
                        const geo = new THREE.ShapeGeometry(shape);
                        const signMat = new THREE.MeshLambertMaterial({ color: 0xffff00, side: THREE.DoubleSide });
                        const sign = new THREE.Mesh(geo, signMat);
                        sign.position.set(0, 3.8, 0);
                        g.add(sign);
                        // Black border
                        const borderMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                        const b1 = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.06, 0.02), borderMat);
                        b1.position.set(0, 3.5, 0.01); b1.rotation.z = 0; g.add(b1);
                    } else if (type === 'chevron') {
                        // Chevron arrow sign
                        const signMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
                        const sign = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 0.05), signMat);
                        sign.position.set(0, 3.5, 0); g.add(sign);
                        // Yellow chevrons
                        const chevMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
                        for (let i = 0; i < 2; i++) {
                            const chev = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.06), chevMat);
                            chev.position.set(-0.2 + i * 0.4, 3.5, 0.03);
                            chev.rotation.z = i === 0 ? 0.5 : -0.5;
                            g.add(chev);
                        }
                    }
                    return g;
                };

                // createGuardrail(): Metal rail with evenly-spaced posts.
                const createGuardrail = (length) => {
                    const g = new THREE.Group();
                    const metalMat = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
                    const postMat = new THREE.MeshLambertMaterial({ color: 0x666666 });

                    // Main rail
                    const rail = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, length), metalMat);
                    rail.position.y = 0.6; g.add(rail);

                    // Posts
                    const numPosts = Math.floor(length / 3);
                    for (let i = 0; i <= numPosts; i++) {
                        const post = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.8, 0.15), postMat);
                        post.position.set(0, 0.4, -length / 2 + i * 3);
                        g.add(post);
                    }

                    return g;
                };

                // createRoadTexture(): Procedural asphalt texture with noise grain.
                const createRoadTexture = () => {
                    const size = 512;
                    const canvas = document.createElement('canvas');
                    canvas.width = size; canvas.height = size;
                    const ctx = canvas.getContext('2d');

                    // Base asphalt
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(0, 0, size, size);

                    // Add subtle noise/grain for asphalt texture
                    for (let i = 0; i < 2000; i++) {
                        const x = Math.random() * size;
                        const y = Math.random() * size;
                        const gray = 55 + Math.random() * 15;
                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        ctx.fillRect(x, y, 1, 1);
                    }

                    const tex = new THREE.CanvasTexture(canvas);
                    tex.wrapS = THREE.RepeatWrapping;
                    tex.wrapT = THREE.RepeatWrapping;
                    tex.repeat.set(2, 2);
                    return tex;
                };

                // ‚îÄ‚îÄ Exhaust Particle System ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Exhaust smoke particles (semi-transparent spheres).
                const exhaustParticles = [];
                const exhaustMat = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.3 });
                for (let i = 0; i < 40; i++) {
                    const size = 0.2 + Math.random() * 0.3;
                    const exhaust = new THREE.Mesh(new THREE.SphereGeometry(size, 6, 6), exhaustMat.clone());
                    exhaust.visible = false;
                    scene.add(exhaust);
                    exhaustParticles.push({ mesh: exhaust, life: 0, active: false, vx: 0, vy: 0, vz: 0 });
                }
                const spawnExhaust = (x, y, z) => {
                    const p = exhaustParticles.find(e => !e.active);
                    if (p) {
                        p.mesh.position.set(x + (Math.random() - 0.5) * 0.3, y, z);
                        p.mesh.scale.set(0.5, 0.5, 0.5);
                        p.mesh.material.opacity = 0.4;
                        p.mesh.visible = true;
                        p.active = true;
                        p.life = 25 + Math.random() * 15;
                        p.vx = (Math.random() - 0.5) * 0.02;
                        p.vy = 0.03 + Math.random() * 0.02;
                        p.vz = 0.1 + Math.random() * 0.05;
                    }
                };

                // ‚îÄ‚îÄ Pre-cached Tree Materials & Geometries ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const treeLeaveMats = {
                    pine: new THREE.MeshLambertMaterial({ color: 0x2d5a27 }),
                    green1: new THREE.MeshLambertMaterial({ color: 0x228B22 }),
                    green2: new THREE.MeshLambertMaterial({ color: 0x006400 }),
                    green3: new THREE.MeshLambertMaterial({ color: 0x32CD32 }),
                    pink: new THREE.MeshLambertMaterial({ color: 0xFFB7C5 }),
                    hotpink: new THREE.MeshLambertMaterial({ color: 0xFF69B4 }),
                    orange: new THREE.MeshLambertMaterial({ color: 0xFFA500 }),
                    yellowTree: new THREE.MeshLambertMaterial({ color: 0xFFFF00 }),
                };
                const treeGeos = {
                    trunkPine: getCylGeo(0.4, 0.6, 2, 6),
                    trunkRound: getCylGeo(0.5, 0.7, 3, 6),
                    trunkColor: getCylGeo(0.5, 0.7, 3.5, 6),
                    cone1: new THREE.ConeGeometry(2.5, 3, 6),
                    cone2: new THREE.ConeGeometry(1.8, 2.5, 6),
                    cone3: new THREE.ConeGeometry(1.2, 2, 6),
                    ico1: new THREE.IcosahedronGeometry(2.2, 0),
                    ico2: new THREE.IcosahedronGeometry(1.5, 0),
                    dodec: new THREE.DodecahedronGeometry(2.5),
                };

                // ‚îÄ‚îÄ createTree() ‚Äî Random tree variant ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // 30% Pine, 30% Round (green), 40% Colourful (pink/orange/yellow).
                const createTree = () => {
                    const g = new THREE.Group();
                    const t = Math.random();
                    if (t < 0.3) {
                        const trunk = new THREE.Mesh(treeGeos.trunkPine, matCache.trunk);
                        trunk.position.y = 1; g.add(trunk);
                        const l1 = new THREE.Mesh(treeGeos.cone1, treeLeaveMats.pine); l1.position.y = 3; g.add(l1);
                        const l2 = new THREE.Mesh(treeGeos.cone2, treeLeaveMats.pine); l2.position.y = 4.5; g.add(l2);
                    } else if (t < 0.6) {
                        const trunk = new THREE.Mesh(treeGeos.trunkRound, matCache.trunk);
                        trunk.position.y = 1.5; g.add(trunk);
                        const cols = [treeLeaveMats.green1, treeLeaveMats.green2, treeLeaveMats.green3];
                        const lm = cols[Math.floor(Math.random() * 3)];
                        const main = new THREE.Mesh(treeGeos.ico1, lm); main.position.y = 4; g.add(main);
                        const sub1 = new THREE.Mesh(treeGeos.ico2, lm); sub1.position.set(1, 4.5, 0); g.add(sub1);
                    } else {
                        const trunk = new THREE.Mesh(treeGeos.trunkColor, matCache.trunk);
                        trunk.position.y = 1.75; g.add(trunk);
                        const cols = [treeLeaveMats.pink, treeLeaveMats.hotpink, treeLeaveMats.orange, treeLeaveMats.yellowTree];
                        const lm = cols[Math.floor(Math.random() * 4)];
                        const l = new THREE.Mesh(treeGeos.dodec, lm); l.position.y = 4.5; g.add(l);
                    }
                    g.scale.set(1.3, 1.3, 1.3);
                    return g;
                };

                // ‚îÄ‚îÄ createCar() ‚Äî Traffic Vehicle Models ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Types: 'sport', 'ambulance', 'van', 'truck', 'police', 'sedan'.
                const createCar = (t, c) => {
                    const g = new THREE.Group();
                    const bm = new THREE.MeshLambertMaterial({ color: c });
                    const dm = new THREE.MeshLambertMaterial({ color: 0x222222 }); // dark/window
                    const wm = new THREE.MeshLambertMaterial({ color: 0xffffff }); // lighter
                    const lm = new THREE.MeshLambertMaterial({ color: 0xffff00 }); // headlights
                    const rm = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // tail/siren
                    const gm = new THREE.MeshLambertMaterial({ color: 0x888888 }); // grey/rims
                    const tire = new THREE.MeshLambertMaterial({ color: 0x111111 });

                    const mb = (w, h, d, mat, x, y, z, rx = 0) => { const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat); m.position.set(x, y, z); if (rx) m.rotation.x = rx; m.castShadow = true; g.add(m); return m; };

                    // Wheels
                    const mw = (z) => {
                        const wg = new THREE.CylinderGeometry(0.55, 0.55, 0.4, 8); wg.rotateZ(Math.PI / 2);
                        [1.3, -1.3].forEach(x => {
                            const w = new THREE.Mesh(wg, tire); w.position.set(x, 0.55, z); w.castShadow = true; g.add(w);
                            const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.45, 8), gm); hub.rotateZ(Math.PI / 2); hub.position.set(x, 0.55, z); g.add(hub);
                        });
                    };
                    mw(1.4); mw(-1.4);

                    const by = 0.9;
                    // Car Body - Model faces -Z (Front), +Z (Back)

                    if (t === 'sport') {
                        // Cute toy car - chunky boxy body
                        mb(2.6, 1.0, 4.5, bm, 0, by + 0.1, 0); // Main body - wide & tall
                        mb(2.4, 0.2, 1.8, bm, 0, by + 0.6, -1.2); // Hood/bonnet slope
                        // Cabin - big and boxy, sits toward back
                        mb(2.3, 0.9, 2.2, dm, 0, by + 0.85, 0.4); // Windows (dark)
                        mb(2.5, 0.15, 2.3, bm, 0, by + 1.3, 0.4); // Roof
                        // Front bumper
                        mb(2.6, 0.3, 0.15, bm, 0, by - 0.15, -2.3);
                        // Rear bumper
                        mb(2.6, 0.3, 0.15, bm, 0, by - 0.15, 2.3);
                        // Big round headlights
                        [0.85, -0.85].forEach(x => {
                            mb(0.5, 0.45, 0.15, lm, x, by + 0.25, -2.3); // Headlights
                            mb(0.45, 0.35, 0.15, rm, x, by + 0.3, 2.3); // Tail lights
                        });
                    } else if (t === 'ambulance') {
                        mb(2.4, 1.2, 4.6, wm, 0, by + 0.3, 0);
                        mb(2.2, 1.0, 1.5, dm, 0, by + 0.6, -1.6); // Front Window
                        // Cross
                        mb(0.4, 1.2, 0.1, rm, 0, by + 0.5, 2.31); mb(1.2, 0.4, 0.1, rm, 0, by + 0.5, 2.31);
                        // Siren
                        mb(0.4, 0.3, 0.4, rm, -0.6, by + 1.0, -1.5); mb(0.4, 0.3, 0.4, rm, 0.6, by + 1.0, -1.5);
                        // Lights
                        mb(0.5, 0.3, 0.1, lm, -0.8, by, -2.3); mb(0.5, 0.3, 0.1, lm, 0.8, by, -2.3);
                        mb(2.4, 0.3, 0.1, rm, 0, by + 0.8, 2.3);
                    } else if (t === 'van') {
                        mb(2.4, 1.4, 4.5, bm, 0, by + 0.4, 0);
                        mb(2.3, 0.7, 1.2, dm, 0, by + 0.9, -1.6); // Windshield
                        mb(0.5, 0.3, 0.1, lm, -0.8, by + 0.1, -2.25); mb(0.5, 0.3, 0.1, lm, 0.8, by + 0.1, -2.25);
                        mb(0.3, 0.6, 0.1, rm, -1.0, by + 0.5, 2.25); mb(0.3, 0.6, 0.1, rm, 1.0, by + 0.5, 2.25);
                    } else if (t === 'truck') {
                        // Truck Logic
                        mb(2.5, 2.0, 2.0, bm, 0, by + 1.0, -1.5); // Cabin
                        mb(2.3, 1.0, 0.1, dm, 0, by + 1.5, -2.55); // Windshield
                        mb(2.8, 3.2, 5.5, new THREE.MeshLambertMaterial({ color: 0xcccccc }), 0, by + 1.8, 2.5); // Cargo
                        mw(1.5); mw(-1.5); mw(4.0); // Extra wheels
                        mb(0.5, 0.3, 0.1, lm, -1.0, by + 0.5, -2.6); mb(0.5, 0.3, 0.1, lm, 1.0, by + 0.5, -2.6); // Headlights
                        mb(0.4, 1.0, 0.1, rm, -1.2, by + 1.5, 5.3); mb(0.4, 1.0, 0.1, rm, 1.2, by + 1.5, 5.3); // Tail Lights
                    } else {
                        // Sedan/Police
                        const mat = t === 'police' ? tire : bm; // Police black bottom
                        const topMat = t === 'police' ? wm : bm;
                        mb(2.4, 0.8, 4.6, mat, 0, by + 0.1, 0);
                        mb(2.4, 0.6, 2.2, topMat, 0, by + 0.1, -0.5); // Doors
                        mb(2.2, 0.7, 2.5, dm, 0, by + 0.7, -0.2); // Cabin
                        mb(2.3, 0.1, 2.4, topMat, 0, by + 1.06, -0.2); // Roof

                        mb(0.5, 0.2, 0.1, lm, -0.8, by + 0.2, -2.3); mb(0.5, 0.2, 0.1, lm, 0.8, by + 0.2, -2.3);
                        mb(0.6, 0.2, 0.1, rm, -0.8, by + 0.3, 2.3); mb(0.6, 0.2, 0.1, rm, 0.8, by + 0.3, 2.3);

                        if (t === 'police') {
                            mb(1.4, 0.15, 0.3, gm, 0, by + 1.15, -0.2);
                            mb(0.3, 0.25, 0.25, rm, -0.6, by + 1.15, -0.2);
                            mb(0.3, 0.25, 0.25, new THREE.MeshLambertMaterial({ color: 0x2196F3 }), 0.6, by + 1.15, -0.2);
                        }
                    }
                    g.scale.set(2.0, 2.0, 2.0);
                    return g;
                };

                // ‚îÄ‚îÄ createMotorcycle() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Separate from createCar to avoid type-check complexity.
                const createMotorcycle = (col) => {
                    const g = new THREE.Group();
                    const bm = new THREE.MeshLambertMaterial({ color: col });
                    const dm = new THREE.MeshLambertMaterial({ color: 0x222222 });
                    const lm = new THREE.MeshLambertMaterial({ color: 0xffff00 });
                    const tireMat = new THREE.MeshLambertMaterial({ color: 0x111111 });

                    const mb = (w, h, d, mat, x, y, z) => {
                        const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                        m.position.set(x, y, z); m.castShadow = true; g.add(m);
                    };

                    // Wheels
                    const wg = new THREE.CylinderGeometry(0.55, 0.55, 0.3, 8);
                    wg.rotateZ(Math.PI / 2);
                    const w1 = new THREE.Mesh(wg, tireMat); w1.position.set(0, 0.55, 1.2); g.add(w1);
                    const w2 = new THREE.Mesh(new THREE.CylinderGeometry(0.55, 0.55, 0.3, 8).rotateZ(Math.PI / 2), tireMat);
                    w2.position.set(0, 0.55, -1.2); g.add(w2);

                    // Body
                    mb(0.5, 0.6, 1.8, bm, 0, 1.0, 0);
                    mb(0.7, 0.1, 0.3, dm, 0, 1.35, -0.7);
                    mb(0.3, 0.4, 0.5, dm, 0, 1.1, -0.9);
                    mb(0.2, 0.3, 0.2, lm, 0, 1.3, -1.2);

                    // Rider
                    const shirt = new THREE.MeshLambertMaterial({ color: 0x3366cc });
                    const helmet = new THREE.MeshLambertMaterial({ color: 0x222222 });
                    mb(0.6, 0.8, 0.4, shirt, 0, 1.7, 0.2);
                    mb(0.5, 0.5, 0.5, helmet, 0, 2.3, 0.2);
                    mb(0.2, 0.2, 0.5, shirt, 0.4, 1.8, -0.3);
                    mb(0.2, 0.2, 0.5, shirt, -0.4, 1.8, -0.3);

                    g.scale.set(2.0, 2.0, 2.0);
                    return g;
                };

                // ‚îÄ‚îÄ Player Car Instance ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const playerCar = createCar('sport', 0xFF0055); scene.add(playerCar);

                // ‚îÄ‚îÄ Dust/Smoke Particle System ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const dustParticles = [];
                const dustMat = new THREE.MeshBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.6 });
                const createDustParticle = () => {
                    const size = 0.3 + Math.random() * 0.5;
                    const geo = new THREE.BoxGeometry(size, size, size);
                    const dust = new THREE.Mesh(geo, dustMat.clone());
                    dust.material.opacity = 0.7;
                    return dust;
                };
                // Pre-create dust particles (reduced for performance)
                for (let i = 0; i < 10; i++) {
                    const dust = createDustParticle();
                    dust.visible = false;
                    scene.add(dust);
                    dustParticles.push({ mesh: dust, life: 0, active: false });
                }
                const spawnDust = (x, z, speed) => {
                    for (let i = 0; i < 3; i++) {
                        const p = dustParticles.find(d => !d.active);
                        if (p) {
                            p.mesh.position.set(x + (Math.random() - 0.5) * 2, 0.3 + Math.random() * 0.5, z + 3);
                            p.mesh.scale.set(1, 1, 1);
                            p.mesh.material.opacity = 0.5 + speed * 0.3;
                            p.mesh.visible = true;
                            p.active = true;
                            p.life = 30 + Math.random() * 20;
                            p.vx = (Math.random() - 0.5) * 0.1;
                            p.vy = 0.02 + Math.random() * 0.03;
                        }
                    }
                };

                // ‚îÄ‚îÄ Infinite Road Grid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // NUM_ROWS of road segments are recycled in a ring buffer
                // to create an endlessly scrolling road.
                const GRID_STEP = 15; const NUM_ROWS = 35; const START_Z = -250;
                const roadTex = createRoadTexture();
                const roadMat = new THREE.MeshLambertMaterial({ map: roadTex, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1 });
                const grassMat = new THREE.MeshLambertMaterial({ color: 0x2d5a27 });
                const markMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                const curbMat = new THREE.MeshLambertMaterial({ color: 0x666666 });

                for (let i = 0; i < NUM_ROWS; i++) {
                    const z = START_Z + (i * GRID_STEP);
                    const rowG = new THREE.Group(); rowG.position.z = z;

                    // High Res Road (15 steps) + Overlap (18 size)
                    const rSeg = new THREE.Mesh(new THREE.PlaneGeometry(30, 18), roadMat.clone());
                    rSeg.rotation.x = -Math.PI / 2; rSeg.receiveShadow = true; rowG.add(rSeg);

                    // Road curbs (elevated edges)
                    const curbL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 17), curbMat);
                    curbL.position.set(-15.25, 0.1, 0); rowG.add(curbL);
                    const curbR = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 17), curbMat);
                    curbR.position.set(15.25, 0.1, 0); rowG.add(curbR);

                    const gL = new THREE.Mesh(new THREE.BoxGeometry(250, 1, 18), grassMat); gL.position.set(-140, -0.6, 0); rowG.add(gL);
                    const gR = new THREE.Mesh(new THREE.BoxGeometry(250, 1, 18), grassMat); gR.position.set(140, -0.6, 0); rowG.add(gR);

                    // Markings - 1 long one or 2 short ones? With step 15, let's do 1 centered marking strip
                    // Or keep the dotted look. 15 length is short.
                    // Put 1 marking at z=0 (relative to row center)
                    const m = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 8), markMat);
                    m.position.set(-5, 0.05, 0); rowG.add(m.clone());
                    m.position.set(5, 0.05, 0); rowG.add(m);

                    // Edge lines (white lines on road sides)
                    const edgeL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.02, 17), markMat);
                    edgeL.position.set(-14.5, 0.03, 0); rowG.add(edgeL);
                    const edgeR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.02, 17), markMat);
                    edgeR.position.set(14.5, 0.03, 0); rowG.add(edgeR);

                    // Trees - inner (close to road), mid, and outer (far from road)
                    const tL = createTree(); tL.position.set(-22 + (Math.random() - 0.5) * 4, 0, 0);
                    const tR = createTree(); tR.position.set(22 + (Math.random() - 0.5) * 4, 0, 0);
                    const tML = createTree(); tML.position.set(-38 + (Math.random() - 0.5) * 4, 0, 0);
                    const tMR = createTree(); tMR.position.set(38 + (Math.random() - 0.5) * 4, 0, 0);
                    const tOL = createTree(); tOL.position.set(-55 + (Math.random() - 0.5) * 6, 0, 0);
                    const tOR = createTree(); tOR.position.set(55 + (Math.random() - 0.5) * 6, 0, 0);
                    // Buildings with randomized positions to prevent overlap
                    const buildOffsetL = -38 - Math.random() * 12; // -38 to -50
                    const buildOffsetR = 38 + Math.random() * 12;  // 38 to 50
                    const bL = createMultiBuilding(); bL.position.set(buildOffsetL, 0, 0); bL.rotation.y = Math.PI / 2;
                    const bR = createMultiBuilding(); bR.position.set(buildOffsetR, 0, 0); bR.rotation.y = -Math.PI / 2;

                    // Guardrails (every 3rd row, alternating sides)
                    let guardL = null, guardR = null;
                    if (i % 3 === 0 && Math.random() > 0.5) {
                        guardL = createGuardrail(14);
                        guardL.position.set(-16.5, 0, 0);
                        guardL.visible = false;
                        rowG.add(guardL);
                    }
                    if (i % 3 === 1 && Math.random() > 0.5) {
                        guardR = createGuardrail(14);
                        guardR.position.set(16.5, 0, 0);
                        guardR.visible = false;
                        rowG.add(guardR);
                    }

                    // Road signs (occasional)
                    let signL = null, signR = null;
                    if (i % 8 === 0 && Math.random() > 0.4) {
                        const signTypes = ['speed', 'warning', 'chevron'];
                        signL = createRoadSign(signTypes[Math.floor(Math.random() * signTypes.length)]);
                        signL.position.set(-18, 0, 0);
                        signL.visible = true;
                        rowG.add(signL);
                    }
                    if (i % 10 === 5 && Math.random() > 0.5) {
                        signR = createRoadSign('chevron');
                        signR.position.set(18, 0, 0);
                        signR.rotation.y = Math.PI;
                        signR.visible = true;
                        rowG.add(signR);
                    }

                    rowG.add(tL, tR, tML, tMR, tOL, tOR, bL, bR); scene.add(rowG);
                    const rowObj = {
                        mesh: rowG, z: z,
                        treeInnerL: tL, treeInnerR: tR,
                        treeMidL: tML, treeMidR: tMR,
                        treeOuterL: tOL, treeOuterR: tOR,
                        buildL: bL, buildR: bR,
                        guardL: guardL, guardR: guardR,
                        signL: signL, signR: signR
                    };
                    updateRowVisuals(rowObj, true); gameStateRef.current.gridRows.push(rowObj);
                }
                // ‚îÄ‚îÄ Clouds & Birds Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Reduced count for performance.
                for (let i = 0; i < 8; i++) {
                    const c = createCloud();
                    c.position.set((Math.random() - 0.5) * 200, 80 + Math.random() * 50, -300 + Math.random() * 600);
                    scene.add(c);
                    gameStateRef.current.clouds.push({ mesh: c, speed: 0.05 + Math.random() * 0.1 });
                }
                for (let i = 0; i < 4; i++) {
                    const b = createBird();
                    b.position.set((Math.random() - 0.5) * 200, 15 + Math.random() * 30, -200 + Math.random() * 400);
                    b.rotation.y = Math.PI / 2;
                    scene.add(b);
                    gameStateRef.current.birds.push({ mesh: b, speed: 0.2 + Math.random() * 0.3, phase: Math.random() * Math.PI * 2 });
                }
                // ‚îÄ‚îÄ Keyboard Input Handling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const keys = {}; const onKey = (e) => keys[e.key] = e.type === 'keydown';
                window.addEventListener('keydown', onKey); window.addEventListener('keyup', onKey);
                camera.position.set(0, 12, 40); let speed = 0; let spawnTimer = 0;
                let currentRot = 0, currentTilt = 0;
                const LANES = [-10, 0, 10];   // Left, Centre, Right lane X positions
                let steerCurrent = 0; let steerTarget = 0;

                const cachedGearDisplay = document.getElementById('gear-indicator');
                const cachedBpmDisplay = document.getElementById('bpm-tracker');

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                //  MAIN GAME LOOP (requestAnimationFrame)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const animate = () => {
                    requestAnimationFrame(animate);
                    const isPlaying = gameStateRef.current.gameStarted && !gameStateRef.current.isGameOver && !gameStateRef.current.isPaused;
                    if (cachedGearDisplay) cachedGearDisplay.style.display = isPlaying ? 'block' : 'none';
                    if (cachedBpmDisplay) cachedBpmDisplay.style.display = isPlaying ? 'block' : 'none';

                    // ‚îÄ‚îÄ Pause / Game-Over guard ‚îÄ‚îÄ
                    if (!gameStateRef.current.gameStarted || gameStateRef.current.isGameOver || gameStateRef.current.isPaused) { renderer.render(scene, camera); return; }

                    // ‚îÄ‚îÄ Reset state after restart ‚îÄ‚îÄ
                    if (gameStateRef.current.needsReset) { gameStateRef.current.needsReset = false; speed = 0; steerCurrent = 0; steerTarget = 0; currentRot = 0; currentTilt = 0; spawnTimer = 0; playerCar.position.x = 0; playerCar.rotation.y = 0; playerCar.rotation.z = 0; camera.position.x = 0; }

                    // ‚îÄ‚îÄ Track play time & distance ‚îÄ‚îÄ
                    if (speed > 0) { gameStateRef.current.movingTime += 0.016; gameStateRef.current.totalDistance += speed; }

                    // === VISUAL EFFECTS UPDATE ===
                    // Speed lines effect
                    updateSpeedLines(speed);





                    // Animate all particles (sparks, dust, exhaust) in one loop pattern
                    const sparks = gameStateRef.current.sparkParticles;
                    for (let i = 0; i < sparks.length; i++) {
                        const p = sparks[i]; if (!p.active) continue;
                        p.life--; p.mesh.position.x += p.vx; p.mesh.position.y += p.vy; p.mesh.position.z += p.vz + speed; p.vy -= 0.015;
                        if (p.life <= 0 || p.mesh.position.y < 0) { p.active = false; p.mesh.visible = false; }
                    }
                    for (let i = 0; i < dustParticles.length; i++) {
                        const p = dustParticles[i]; if (!p.active) continue;
                        p.life--; p.mesh.position.x += p.vx; p.mesh.position.y += p.vy; p.mesh.position.z += speed * 0.5;
                        p.mesh.scale.multiplyScalar(1.02); p.mesh.material.opacity *= 0.95;
                        if (p.life <= 0 || p.mesh.material.opacity < 0.05) { p.active = false; p.mesh.visible = false; }
                    }
                    for (let i = 0; i < exhaustParticles.length; i++) {
                        const p = exhaustParticles[i]; if (!p.active) continue;
                        p.life--; p.mesh.position.x += p.vx; p.mesh.position.y += p.vy; p.mesh.position.z += p.vz + speed;
                        p.mesh.scale.multiplyScalar(1.03); p.mesh.material.opacity *= 0.95;
                        if (p.life <= 0 || p.mesh.material.opacity < 0.02) { p.active = false; p.mesh.visible = false; }
                    }
                    // Clouds & birds
                    const gs = gameStateRef.current;
                    for (let i = 0; i < gs.clouds.length; i++) {
                        const c = gs.clouds[i]; c.mesh.position.z += c.speed + (speed * 0.5);
                        if (c.mesh.position.z > 100) c.mesh.position.z = -400;
                    }
                    for (let i = 0; i < gs.birds.length; i++) {
                        const b = gs.birds[i]; b.mesh.position.x += b.speed;
                        b.mesh.position.y += Math.sin(gs.movingTime * 5 + b.phase) * 0.05;
                        b.mesh.position.z += speed * 0.8;
                        if (b.mesh.userData.wingL) {
                            const flapAngle = Math.sin(gs.movingTime * 15 + b.phase) * 0.6;
                            b.mesh.userData.wingL.rotation.x = flapAngle; b.mesh.userData.wingR.rotation.x = flapAngle;
                        }
                        if (b.mesh.position.x > 150) b.mesh.position.x = -150;
                        if (b.mesh.position.z > 100) b.mesh.position.z = -300;
                    }
                    // Spawn dust & exhaust
                    if (speed > 0.3 && Math.random() > 0.7) spawnDust(playerCar.position.x, playerCar.position.z, speed);
                    if (speed > 0.2 && Math.random() > 0.6) spawnExhaust(playerCar.position.x, 0.5, playerCar.position.z + 4);
                    // ‚îÄ‚îÄ Difficulty Scaling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                    // Progressive mode: difficulty ramps with score.
                    // Fixed modes: constant difficulty parameters.
                    const t = gameStateRef.current.movingTime; const diffMode = gameStateRef.current.difficulty;
                    const currentScore = gameStateRef.current.score;
                    let laneSwitchProb = 0, spawnRate = 80, laneChangeDistance = 80;
                    if (diffMode === 'Progressive') {
                        // Easy (0-2000)
                        if (currentScore <= 2000) {
                            // Default easy settings
                        }
                        // Medium (2000-4000)
                        else if (currentScore > 2000 && currentScore <= 4000) {
                            laneSwitchProb = 0.002; spawnRate = 60; laneChangeDistance = 100;
                        }
                        // Hard (4000-6000)
                        else if (currentScore > 4000 && currentScore <= 6000) {
                            laneSwitchProb = 0.008; spawnRate = 55; laneChangeDistance = 120;
                        }
                        // Challenging (6000+)
                        else if (currentScore > 6000) {
                            laneSwitchProb = 0.015; spawnRate = 45; laneChangeDistance = 140;
                        }
                    } else { if (diffMode === 'Medium') { laneSwitchProb = 0.002; spawnRate = 60; laneChangeDistance = 100; } else if (diffMode === 'Hard') { laneSwitchProb = 0.008; spawnRate = 55; laneChangeDistance = 120; } }

                    // ‚îÄ‚îÄ Throttle Input (BLE encoder or keyboard) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                    let bikeSpeed = throttleBtRef.current.throttle;
                    const keyboardActive = (keys['w'] || keys['ArrowUp']);
                    if (keyboardActive) {
                        speed = Math.min(speed + 0.0065, 1.4);
                    } else if (bikeSpeed > 0.005) {
                        speed = Math.min(bikeSpeed * sensitivityRef.current * 0.23, 1.4);
                    } else {
                        speed *= 0.995;
                        if (speed < 0.005) speed = 0;
                    }

                    // ‚îÄ‚îÄ Steering Input (BLE tilt or keyboard) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                    steerTarget = 0; const tiltValue = btRef.current.tilt;
                    if (keys['a'] || keys['ArrowLeft']) { steerTarget = -0.3; } else if (keys['d'] || keys['ArrowRight']) { steerTarget = 0.3; } else if (tiltValue <= -2.8) { steerTarget = -0.3; } else if (tiltValue >= 2.8) { steerTarget = 0.3; }
                    const STEER_SMOOTH = 0.15; steerCurrent += (steerTarget - steerCurrent) * STEER_SMOOTH; if (Math.abs(steerCurrent) < 0.02) steerCurrent = 0;
                    if ((playerCar.position.x > -13 && steerCurrent < 0) || (playerCar.position.x < 13 && steerCurrent > 0)) { playerCar.position.x += steerCurrent; }
                    playerCar.position.x = Math.max(-13, Math.min(13, playerCar.position.x));

                    // ‚îÄ‚îÄ Car Visual Tilt & Camera Follow ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                    const tr = -steerCurrent * 0.3; const tt = -steerCurrent * 0.15; currentRot += (tr - currentRot) * 0.1; currentTilt += (tt - currentTilt) * 0.1; playerCar.rotation.y = currentRot; playerCar.rotation.z = currentTilt;
                    camera.position.x = playerCar.position.x * 0.6; camera.lookAt(playerCar.position.x * 0.3, 2, -50);

                    // ‚îÄ‚îÄ Road Scrolling & Rural/Urban Cycle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                    if (speed > 0) {
                        gameStateRef.current.score += speed;
                        setScore(Math.floor(gameStateRef.current.score));

                        const cyclePos = gameStateRef.current.totalDistance % 1400;
                        const isRural = cyclePos < 600;
                        const rows = gameStateRef.current.gridRows;
                        let minZ = 10000;
                        for (let i = 0; i < rows.length; i++) minZ = Math.min(minZ, rows[i].z);
                        for (let i = 0; i < rows.length; i++) {
                            const row = rows[i];
                            row.z += speed;
                            if (row.z > 80) { row.z = minZ - GRID_STEP; minZ = row.z; updateRowVisuals(row, isRural); }
                            row.mesh.position.z = row.z;
                        }
                    }

                    // ‚îÄ‚îÄ Traffic Spawning ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                    const trafficSpeed = 0.6 + speed; spawnTimer += trafficSpeed;
                    if (spawnTimer > spawnRate) {
                        spawnTimer = 0; const r = Math.random(); let type = 'sedan'; let col = 0x555555;
                        if (r < 0.12) { type = 'truck'; col = [0x1144AA, 0xAA2222, 0x333333][Math.floor(Math.random() * 3)]; }
                        else if (r < 0.22) type = 'police';
                        else if (r < 0.32) { type = 'ambulance'; }
                        else if (r < 0.45) { type = 'van'; col = [0xAA0000, 0x0000AA, 0x228B22][Math.floor(Math.random() * 3)]; }
                        else if (r < 0.55) { type = 'motorcycle'; col = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00][Math.floor(Math.random() * 4)]; }
                        else if (r < 0.70) { type = 'sport'; col = 0x00FF00; }
                        else col = [0xAA0000, 0x0000AA, 0x228B22, 0xFF8C00, 0x8A2BE2, 0x00FFFF][Math.floor(Math.random() * 6)];

                        const laneIdx = Math.floor(Math.random() * LANES.length);
                        const logicX = LANES[laneIdx];
                        const c = (type === 'motorcycle') ? createMotorcycle(col) : createCar(type, col);
                        c.rotation.y = Math.PI; scene.add(c);
                        gameStateRef.current.opponents.push({ mesh: c, laneIdx: laneIdx, logicX: logicX }); // Added logicX

                        // Initial position calc
                        c.position.set(logicX, 0, -250);
                    }

                    // ‚îÄ‚îÄ Traffic Movement, Lane Switching & Collision ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                    const ops = gameStateRef.current.opponents;
                    for (let i = ops.length - 1; i >= 0; i--) {
                        const opp = ops[i];
                        opp.mesh.position.z += trafficSpeed;

                        // Lane Switching Logic
                        const distanceFromPlayer = opp.mesh.position.z - playerCar.position.z;
                        if (laneSwitchProb > 0 && Math.random() < laneSwitchProb && distanceFromPlayer < -laneChangeDistance) {
                            const next = opp.laneIdx + (Math.random() > 0.5 ? 1 : -1);
                            if (next >= 0 && next <= 2) opp.laneIdx = next;
                        }

                        // Logic X Movement (Lane changing)
                        const targetX = LANES[opp.laneIdx];
                        const dx = targetX - opp.logicX; // Use logicX
                        if (Math.abs(dx) > 0.1) {
                            opp.logicX += dx * 0.03;
                            opp.mesh.rotation.y = Math.PI + (dx > 0 ? -0.1 : 0.1);
                        } else {
                            opp.mesh.rotation.y = Math.PI;
                        }

                        // Final Position = LogicX + CurveOffset
                        opp.mesh.position.x = opp.logicX;


                        const distanceZ = Math.abs(opp.mesh.position.z - playerCar.position.z);
                        const distanceX = Math.abs(opp.mesh.position.x - playerCar.position.x); // Hitbox uses visual X which is correct
                        if (distanceZ < 8 && distanceX < 5 && !opp.hitCooldown) {
                            console.log("üí• HIT!");
                            playCrashSound();
                            hidePlayerCar(playerCar); // Blink the player car
                            blinkMesh(opp.mesh); // Blink the enemy car too
                            spawnSparks(playerCar.position.x, 1, 0); // Visual sparks
                            gameStateRef.current.lives--;
                            setLives(gameStateRef.current.lives);
                            // Mark this specific enemy as hit - player invincible to it for 1 second
                            opp.hitCooldown = true;
                            setTimeout(() => { opp.hitCooldown = false; }, 1000);
                            if (gameStateRef.current.lives <= 0) {
                                console.log("üíÄ GAME OVER!");
                                stopMusic(); // Reset music on death
                                sendVibration(true, 800);
                                setGameOver(true);
                                gameStateRef.current.isGameOver = true;
                                const h = localStorage.getItem('blockyRacerHighScore') ? parseInt(localStorage.getItem('blockyRacerHighScore')) : 0;
                                if (gameStateRef.current.score > h) {
                                    localStorage.setItem('blockyRacerHighScore', gameStateRef.current.score);
                                    setHighScore(gameStateRef.current.score);
                                    setNewRecord(true);
                                } else {
                                    setNewRecord(false);
                                }
                            } else {
                                sendVibration(true, 400);
                            }
                        } if (opp.mesh.position.z > 80) { scene.remove(opp.mesh); ops.splice(i, 1); }
                    }
                    renderer.render(scene, camera);
                };
                animate();

                // ‚îÄ‚îÄ Window Resize Handler ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const handleResize = () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
                window.addEventListener('resize', handleResize);
                return () => { window.removeEventListener('resize', handleResize); window.removeEventListener('keydown', onKey); window.removeEventListener('keyup', onKey); if (mountRef.current) mountRef.current.innerHTML = ''; };
            }, []);

            // ‚îÄ‚îÄ Audio System ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // initAudio: Create/resume the Web Audio context.
            const initAudio = () => { if (!audioCtxRef.current) { audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)(); } if (audioCtxRef.current.state === 'suspended') { audioCtxRef.current.resume(); } };

            // playCrashSound: Warm triangle-wave thud + soft secondary tone + noise texture.
            const playCrashSound = () => {
                if (!audioCtxRef.current) return;
                const ctx = audioCtxRef.current;

                // 1. Mellow, warm "thud" sound (triangle wave for soft, warm tone)
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'triangle'; // Triangle for soft, warm sound

                // Higher frequencies for mellower, less harsh sound
                osc.frequency.setValueAtTime(200, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.3);

                // Moderate volume with smooth decay
                gain.gain.setValueAtTime(0.35 * volumeRef.current, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

                osc.connect(gain);
                gain.connect(ctx.destination);

                osc.start();
                osc.stop(ctx.currentTime + 0.3);

                // 2. Soft secondary tone for warmth
                const warmOsc = ctx.createOscillator();
                const warmGain = ctx.createGain();
                warmOsc.type = 'sine';
                warmOsc.frequency.setValueAtTime(120, ctx.currentTime);
                warmOsc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.4);
                warmGain.gain.setValueAtTime(0.25 * volumeRef.current, ctx.currentTime);
                warmGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                warmOsc.connect(warmGain);
                warmGain.connect(ctx.destination);
                warmOsc.start();
                warmOsc.stop(ctx.currentTime + 0.4);

                // 2. A tiny bit of noise for texture (crunch), but much quieter
                const bufferSize = ctx.sampleRate * 0.2; // Shorter
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    // Reduce resolution for "bitcrushed" feel? 
                    // Simple random noise is fine if quiet
                    data[i] = (Math.random() * 2 - 1);
                }
                const noise = ctx.createBufferSource();
                const noiseGain = ctx.createGain();
                noise.buffer = buffer;

                // Much quieter than before
                noiseGain.gain.setValueAtTime(0.2 * volumeRef.current, ctx.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);

                noise.connect(noiseGain);
                noiseGain.connect(ctx.destination);
                noise.start();
            };

            // startMusic: Randomly picks a track; on end, picks another random track.
            const startMusic = () => {
                const musicTracks = ['Game Songs/Arcade_Music.mp3', 'Game Songs/Tian_Mimi.mp3', 'Game Songs/Rasa_Sayang_Hey.mp3', 'Game Songs/Cool_Music.mp3'];
                const playRandom = () => {
                    const randomTrack = musicTracks[Math.floor(Math.random() * musicTracks.length)];
                    musicRef.current.src = randomTrack;
                    musicRef.current.volume = volumeRef.current;
                    musicRef.current.currentTime = 0;
                    musicRef.current.play().catch(e => console.log("Audio play failed:", e));
                };
                if (!musicRef.current) {
                    musicRef.current = new Audio();
                    // When a track ends, pick another random one
                    musicRef.current.addEventListener('ended', playRandom);
                }
                playRandom();
            };

            // stopMusic: Pause and reset the music audio element.
            const stopMusic = () => {
                if (musicRef.current) {
                    musicRef.current.pause();
                    musicRef.current.currentTime = 0;
                }
            };

            // ‚îÄ‚îÄ Game Start / Restart Handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const onStartGame = () => { initAudio(); startMusic(); setGameStarted(true); gameStateRef.current.gameStarted = true; gameStateRef.current.isPaused = false; };
            const onPlayAgain = () => {
                triggerRestart();
                initAudio();
                // Ensure music plays properly on restart
                if (musicRef.current) {
                    musicRef.current.pause();
                    musicRef.current.currentTime = 0;
                }
                startMusic();
            };

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            //  JSX Render
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            return (
                <div style={{ width: '100vw', height: '100vh', position: 'relative', overflow: 'hidden' }}>
                    <div ref={mountRef} style={{ width: '100%', height: '100%' }} />
                    {gameStarted && !gameOver && (<>
                        <div id="hud">
                            <div style={{ fontSize: 24, fontWeight: 'bold' }}>{t('score')}: {score}</div>
                            <div style={{ fontSize: 20, fontWeight: 'bold', color: '#FFFF00', marginTop: 5 }}>{t('highScore')}: {highScore}</div>
                            <div style={{ fontSize: 16, color: '#00FF00', marginTop: 5, fontWeight: 'bold' }}>{t('difficulty')}: {uiDifficulty === 'Progressive' ? (gameStateRef.current.score > 6000 ? t('challenging') : gameStateRef.current.score > 4000 ? t('hard') : gameStateRef.current.score > 2000 ? t('medium') : t('easy')) : t(uiDifficulty.toLowerCase())}</div>
                            <div style={{ marginTop: 8 }}>
                                <button onClick={() => {
                                    if (window.calibrateTilt) window.calibrateTilt();
                                    setCalibrated(true);
                                    setTimeout(() => setCalibrated(false), 1500);
                                }} style={{ background: calibrated ? '#4CAF50' : '#9C27B0', color: 'white', border: 'none', borderRadius: 6, padding: '6px 14px', fontSize: 14, fontWeight: 'bold', cursor: 'pointer', transition: 'all 0.3s ease', boxShadow: calibrated ? '0 0 20px rgba(76,175,80,0.8)' : '0 2px 8px rgba(156,39,176,0.4)', transform: calibrated ? 'scale(1.15)' : 'scale(1)' }}>{calibrated ? 'CALIBRATED!' : 'Calibrate'}</button>
                            </div>
                        </div>
                        <div id="lives">
                            <span style={{ color: lives >= 1 ? '#ff0000' : '#666' }}>&#10084;</span>
                            <span style={{ color: lives >= 2 ? '#ff0000' : '#666' }}>&#10084;</span>
                            <span style={{ color: lives >= 3 ? '#ff0000' : '#666' }}>&#10084;</span>
                        </div>
                    </>)}
                    {gameStarted && !gameOver && <div id="menuBtn" onClick={toggleMenu}>{t('menu')}</div>}
                    <div id="sideMenu" className={menuOpen ? 'open' : ''}>
                        <h2 style={{ textAlign: 'center', borderBottom: '1px solid #666', paddingBottom: '5px', marginTop: 0, marginBottom: '5px', fontSize: '18px' }}>{t('paused')}</h2>

                        <div style={{ marginBottom: '8px' }}>
                            <h3 style={{ fontSize: '14px', color: '#aaa', marginTop: 0, marginBottom: '5px' }}>{t('settings')}</h3>
                            <div style={{ padding: '0 10px', marginBottom: '8px' }}>
                                <label style={{ display: 'block', marginBottom: '5px', fontSize: '14px' }}>{t('volume')}: {Math.round(volume * 100)}%</label>
                                <input type="range" min="0" max="1" step="0.1" value={volume} onChange={(e) => setVolume(parseFloat(e.target.value))} style={{ width: '100%' }} />
                            </div>
                            <div style={{ padding: '0 10px', marginBottom: '8px' }}>
                                <label style={{ display: 'block', marginBottom: '5px', fontSize: '14px' }}>{t('sensitivity')}: {sensitivity.toFixed(1)}</label>
                                <input type="range" min="0.1" max="2.0" step="0.1" value={sensitivity} onChange={(e) => setSensitivity(parseFloat(e.target.value))} style={{ width: '100%' }} />
                            </div>
                            <div style={{ padding: '0 10px' }}>
                                <label style={{ display: 'block', marginBottom: '5px', fontSize: '14px' }}>{t('language')}</label>
                                <select value={language} onChange={(e) => changeLanguage(e.target.value)} style={{ width: '100%', padding: '8px', fontSize: '14px', borderRadius: '4px', border: 'none', background: '#333', color: 'white' }}>
                                    <option value="en">English</option>
                                    <option value="zh">‰∏≠Êñá</option>
                                </select>
                            </div>
                        </div>

                        <div style={{ marginBottom: '8px' }}>
                            <h3 style={{ fontSize: '14px', color: '#aaa', marginTop: 0, marginBottom: '5px' }}>{t('difficultyMode')}</h3>
                            <div className={`menu-opt ${uiDifficulty === 'Progressive' ? 'active' : ''}`} onClick={() => changeDifficulty('Progressive')}>{t('progressive')}</div>
                            <div className={`menu-opt ${uiDifficulty === 'Easy' ? 'active' : ''}`} onClick={() => changeDifficulty('Easy')}>{t('fixed')}: {t('easy')}</div>
                            <div className={`menu-opt ${uiDifficulty === 'Medium' ? 'active' : ''}`} onClick={() => changeDifficulty('Medium')}>{t('fixed')}: {t('medium')}</div>
                            <div className={`menu-opt ${uiDifficulty === 'Hard' ? 'active' : ''}`} onClick={() => changeDifficulty('Hard')}>{t('fixed')}: {t('hard')}</div>
                        </div>

                        <div style={{ marginBottom: '8px' }}>
                            <h3 style={{ fontSize: '14px', color: '#aaa', marginTop: 0, marginBottom: '5px' }}>BLE</h3>
                            <div className="menu-opt" style={{ background: btConnected ? '#4CAF50' : btConnecting ? '#FF9800' : '#00BCD4', marginTop: '5px', transition: 'all 0.3s ease', cursor: btConnecting ? 'wait' : 'pointer', opacity: btConnecting ? 0.8 : 1 }} onClick={() => { if (!btConnecting && window.reconnectSteering) window.reconnectSteering(); }} onMouseEnter={(e) => { if (!btConnecting) e.currentTarget.style.transform = 'scale(1.05)'; }} onMouseLeave={(e) => e.currentTarget.style.transform = 'scale(1)'}>{btConnected ? '‚úÖ' : btConnecting ? 'üîÑ' : 'üîå'} {t('pairSteering')} {btConnected ? `(${t('paired')})` : btConnecting ? `(${t('connecting')})` : ''}</div>
                            <div className="menu-opt" style={{ background: thBtConnected ? '#4CAF50' : thBtConnecting ? '#FF9800' : '#00BCD4', marginTop: '5px', transition: 'all 0.3s ease', cursor: thBtConnecting ? 'wait' : 'pointer', opacity: thBtConnecting ? 0.8 : 1 }} onClick={() => { if (!thBtConnecting && window.reconnectThrottle) window.reconnectThrottle(); }} onMouseEnter={(e) => { if (!thBtConnecting) e.currentTarget.style.transform = 'scale(1.05)'; }} onMouseLeave={(e) => e.currentTarget.style.transform = 'scale(1)'}>{thBtConnected ? '‚úÖ' : thBtConnecting ? 'üîÑ' : 'üîå'} {t('pairThrottle')} {thBtConnected ? `(${t('paired')})` : thBtConnecting ? `(${t('connecting')})` : ''}</div>
                        </div>

                        <div style={{ marginBottom: '8px' }}>
                            <h3 style={{ fontSize: '14px', color: '#aaa', marginTop: 0, marginBottom: '5px' }}>üéµ Music</h3>
                            <div className="menu-opt" style={{ background: '#E91E63' }} onClick={() => { if (musicRef.current) { musicRef.current.src = 'Game Songs/Arcade_Music.mp3'; musicRef.current.play(); } }}>üé∂ Arcade music</div>
                            <div className="menu-opt" style={{ background: '#E91E63', marginTop: '5px' }} onClick={() => { if (musicRef.current) { musicRef.current.src = 'Game Songs/Tian_Mimi.mp3'; musicRef.current.play(); } }}>üé∂ Tian Mimi</div>
                            <div className="menu-opt" style={{ background: '#E91E63', marginTop: '5px' }} onClick={() => { if (musicRef.current) { musicRef.current.src = 'Game Songs/Rasa_Sayang_Hey.mp3'; musicRef.current.play(); } }}>üé∂ Rasa Sayang Hey</div>
                            <div className="menu-opt" style={{ background: '#E91E63', marginTop: '5px' }} onClick={() => { if (musicRef.current) { musicRef.current.src = 'Game Songs/Cool_Music.mp3'; musicRef.current.play(); } }}>üé∂ Cool music</div>
                        </div>
                        <div className="menu-opt" style={{ background: '#2196F3', marginTop: 'auto' }} onClick={toggleMenu}>{t('resume')}</div>
                        <div className="menu-opt" style={{ background: '#f44336', marginTop: '8px' }} onClick={() => { setGameStarted(false); setGameOver(false); setScore(0); setLives(3); setNewRecord(false); setMenuOpen(false); const ref = gameStateRef.current; ref.isGameOver = false; ref.isPaused = false; ref.gameStarted = false; ref.score = 0; ref.lives = 3; ref.movingTime = 0; ref.totalDistance = 0; ref.needsReset = true; ref.opponents.forEach(o => { if (o.mesh && o.mesh.parent) o.mesh.parent.remove(o.mesh); }); ref.opponents = []; for (let i = 0; i < ref.gridRows.length; i++) { ref.gridRows[i].z = -350 + (i * 15); ref.gridRows[i].mesh.position.z = ref.gridRows[i].z; ref.gridRows[i].mesh.position.x = 0; ref.gridRows[i].mesh.rotation.y = 0; updateRowVisuals(ref.gridRows[i], true); } stopMusic(); }}>{t('mainMenu')}</div>
                    </div>
                    {
                        !gameStarted && (<div id="overlayScreen"> <h1 style={{ fontSize: '80px', margin: 0, color: '#4CAF50', textShadow: '4px 4px 0 #000' }}>{t('title')}</h1> <p style={{ marginTop: '20px', fontSize: '18px' }}>{t('highScore')}: {highScore}</p> <button className="reset-score-btn" onClick={resetHighScore}>{t('resetScore')}</button>

                            <button className={`bt-btn ${btConnected ? 'connected' : btConnecting ? 'connecting' : ''}`} onClick={!btConnected && !btConnecting ? connectBluetooth : null} disabled={btConnecting}> {btConnected ? `‚úÖ ${t('pairSteering')} ${t('paired')}` : btConnecting ? `üîÑ ${t('connecting')}` : `${t('pairSteering')}`} </button>
                            <button className={`bt-btn ${thBtConnected ? 'connected' : thBtConnecting ? 'connecting' : ''}`} onClick={!thBtConnected && !thBtConnecting ? connectThrottleBluetooth : null} disabled={thBtConnecting}> {thBtConnected ? `‚úÖ ${t('pairThrottle')} ${t('paired')}` : thBtConnecting ? `üîÑ ${t('connecting')}` : `${t('pairThrottle')}`} </button>
                            <button className="big-btn" onClick={onStartGame}>{t('startEngine')}</button>
                            <div style={{ marginTop: '15px' }}><select value={language} onChange={(e) => changeLanguage(e.target.value)} style={{ padding: '10px 20px', fontSize: '16px', borderRadius: '8px', border: '2px solid #4CAF50', background: 'rgba(0, 0, 0, 0.7)', color: 'white', cursor: 'pointer', fontWeight: 'bold' }}><option value="en">English</option><option value="zh">‰∏≠Êñá</option></select></div> </div>)
                    }
                    {gameOver && (<div id="overlayScreen"> <h1 style={{ color: '#ff4444', fontSize: '80px', margin: 0 }}>{t('crashed')}</h1> <p style={{ fontSize: '32px' }}>{t('score')}: {score}</p> {newRecord && <div style={{ background: '#FFD700', color: 'black', padding: '10px 20px', borderRadius: '5px', fontWeight: 'bold', fontSize: '20px', marginBottom: '20px' }}>üèÜ {t('newRecord')} üèÜ</div>} <p style={{ fontSize: '18px', color: '#aaa' }}>{t('pressRestart')}</p> <button className="big-btn" onClick={onPlayAgain}>{t('playAgain')}</button> <div style={{ marginTop: '15px' }}> <button className="restart-btn" onClick={() => { setGameStarted(false); setGameOver(false); setScore(0); setLives(3); setNewRecord(false); setMenuOpen(false); const ref = gameStateRef.current; ref.isGameOver = false; ref.isPaused = false; ref.gameStarted = false; ref.score = 0; ref.lives = 3; ref.movingTime = 0; ref.totalDistance = 0; ref.needsReset = true; ref.opponents.forEach(o => { if (o.mesh && o.mesh.parent) o.mesh.parent.remove(o.mesh); }); ref.opponents = []; for (let i = 0; i < ref.gridRows.length; i++) { ref.gridRows[i].z = -350 + (i * 15); ref.gridRows[i].mesh.position.z = ref.gridRows[i].z; ref.gridRows[i].mesh.position.x = 0; ref.gridRows[i].mesh.rotation.y = 0; updateRowVisuals(ref.gridRows[i], true); } stopMusic(); }}>{t('mainMenu')}</button> </div> </div>)}

                </div >
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<BlockyCarGame />);
    </script>
</body>

</html>
