<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blocky Racer - Audio Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #debug-panel {
            position: fixed; top: 10px; left: 10px; width: 320px;
            background: rgba(0,0,0,0.85); color: #0f0; padding: 12px; border: 1px solid #0f0;
            font-family: monospace; z-index: 1000; font-size: 11px; pointer-events: none;
        }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #111; color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; }
        #hud { position: absolute; top: 20px; right: 20px; color: white; text-shadow: 2px 2px 4px #000; z-index: 10; text-align: right; }
        #overlayScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 50; color: white; backdrop-filter: blur(5px); }
        .big-btn { padding: 20px 50px; font-size: 24px; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; margin-top: 20px; font-weight: bold; transition: transform 0.1s; }
        .big-btn:active { transform: scale(0.95); }
        .bt-btn { padding: 10px 20px; font-size: 14px; background: #2196F3; color: white; border: none; border-radius: 20px; cursor: pointer; margin-top: 10px; }
        .bt-btn.connected { background: #4CAF50; }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>

    <div id="debug-panel">
        <div><b>BLE:</b> <span id="st">DISCONNECTED</span></div>
        <div><b>TILT:</b> <span id="tx">0.00</span> | <b>THROTTLE:</b> <span id="thv">0.00</span></div>
    </div>

    <div id="loader"><h2>LOADING...</h2></div>
    <div id="root"></div>

    <script type="text/babel">
        const { useEffect, useRef, useState } = React;

        // --- THE SOUND SYSTEM ---
        const SoundSystem = {
            ctx: null,
            bgmNode: null,
            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playCrash() {
                this.init();
                const osc = this.ctx.createOscillator();
                const noise = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);

                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            },
            startMusic() {
                this.init();
                if (this.bgmNode) return;

                // Simple 8-bit style rhythmic loop
                let nextNoteTime = this.ctx.currentTime;
                const playNote = () => {
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    const freq = [130.81, 146.83, 164.81, 196.00][Math.floor(Math.random() * 4)];
                    
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(freq, nextNoteTime);
                    g.gain.setValueAtTime(0.05, nextNoteTime);
                    g.gain.exponentialRampToValueAtTime(0.001, nextNoteTime + 0.2);
                    
                    osc.connect(g);
                    g.connect(this.ctx.destination);
                    osc.start(nextNoteTime);
                    osc.stop(nextNoteTime + 0.2);
                    
                    nextNoteTime += 0.25;
                };

                this.bgmNode = setInterval(playNote, 250);
            },
            stopMusic() {
                if (this.bgmNode) clearInterval(this.bgmNode);
                this.bgmNode = null;
            }
        };

        const Game = () => {
            const mountRef = useRef(null);
            const [gameStarted, setGameStarted] = useState(false);
            const [gameOver, setGameOver] = useState(false);
            const [score, setScore] = useState(0);
            const [lives, setLives] = useState(3);
            const [btConnected, setBtConnected] = useState(false);

            const gameState = useRef({ 
                speed: 0, 
                playerX: 0, 
                opponents: [], 
                invincible: 0,
                btData: { tilt: 0, throttle: 0 } 
            });

            useEffect(() => {
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                mountRef.current.appendChild(renderer.domElement);

                // Lighting & Road
                scene.add(new THREE.AmbientLight(0xffffff, 0.7));
                const road = new THREE.Mesh(new THREE.PlaneGeometry(30, 2000), new THREE.MeshLambertMaterial({color: 0x444444}));
                road.rotation.x = -Math.PI/2;
                scene.add(road);

                const player = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshLambertMaterial({color: 0xff0055}));
                player.position.y = 0.5;
                scene.add(player);

                // Simple Obstacle Logic
                const spawnObstacle = () => {
                    const obs = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshLambertMaterial({color: 0x333333}));
                    obs.position.set([-10, 0, 10][Math.floor(Math.random()*3)], 0.5, -200);
                    scene.add(obs);
                    gameState.current.opponents.push(obs);
                };

                // Loader cleanup
                document.getElementById('loader').style.display = 'none';

                const animate = () => {
                    requestAnimationFrame(animate);
                    if (!gameStarted || gameOver) {
                        renderer.render(scene, camera);
                        return;
                    }

                    const gs = gameState.current;
                    // Logic for speed (Keyboard or BT)
                    gs.speed = Math.min(gs.speed + 0.01, 1.0);
                    
                    // Invincibility flash
                    if (gs.invincible > 0) {
                        gs.invincible -= 0.016;
                        player.visible = Math.floor(Date.now() / 100) % 2 === 0;
                    } else {
                        player.visible = true;
                    }

                    // Move obstacles
                    for (let i = gs.opponents.length - 1; i >= 0; i--) {
                        const o = gs.opponents[i];
                        o.position.z += gs.speed + 0.5;

                        // Collision
                        if (Math.abs(o.position.z - player.position.z) < 3 && Math.abs(o.position.x - player.position.x) < 2 && gs.invincible <= 0) {
                            SoundSystem.playCrash();
                            setLives(l => {
                                const newL = l - 1;
                                if (newL <= 0) {
                                    setGameOver(true);
                                    SoundSystem.stopMusic();
                                }
                                return newL;
                            });
                            gs.invincible = 2; // 2 seconds of flash
                        }

                        if (o.position.z > 50) {
                            scene.remove(o);
                            gs.opponents.splice(i, 1);
                            setScore(s => s + 10);
                        }
                    }

                    if (Math.random() < 0.02) spawnObstacle();

                    camera.position.set(player.position.x * 0.5, 10, 25);
                    camera.lookAt(player.position.x, 0, -10);
                    renderer.render(scene, camera);
                };
                animate();
            }, [gameStarted, gameOver]);

            const handleStart = () => {
                SoundSystem.startMusic();
                setGameStarted(true);
            };

            return (
                <div style={{width:'100vw', height:'100vh'}}>
                    <div ref={mountRef} style={{width:'100%', height:'100%'}} />
                    
                    {gameStarted && !gameOver && (
                        <div id="hud">
                            <h2 style={{margin:0}}>Score 分数: {score}</h2>
                            <h2 style={{margin:0, color:'red'}}>{[...Array(lives)].map(()=>'❤')}</h2>
                        </div>
                    )}

                    {!gameStarted && (
                        <div id="overlayScreen">
                            <h1 style={{fontSize:'60px', color:'#4CAF50'}}>BLOCKY RACER</h1>
                            <button className="big-btn" onClick={handleStart}>START ENGINE 启动引擎</button>
                            <p style={{fontSize:'12px'}}>Sound will activate on start / 声音将在启动时激活</p>
                        </div>
                    )}

                    {gameOver && (
                        <div id="overlayScreen">
                            <h1 style={{color:'#ff4444', fontSize:'60px'}}>CRASHED! 撞车了!</h1>
                            <button className="big-btn" onClick={() => window.location.reload()}>PLAY AGAIN 再玩一次</button>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Game />);
    </script>
</body>
</html>
