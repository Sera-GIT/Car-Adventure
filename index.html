<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Car Adventure</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }

        #debug-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 340px;
            background: transparent;
            color: #0f0;
            padding: 15px;
            border: none;
            font-family: monospace;
            z-index: 10000;
            font-size: 10px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #debug-panel .status-connected {
            color: #0f0;
        }

        #debug-panel .status-disconnected {
            color: #f00;
        }

        #debug-panel .status-connecting {
            color: #ff0;
        }

        #debug-panel .vibe-success {
            color: #0f0;
        }

        #debug-panel .vibe-fail {
            color: #f00;
        }

        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 0.5s;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px #000;
            z-index: 10;
            pointer-events: none;
            text-align: left;
        }

        #hud button {
            pointer-events: auto;
        }

        #lives {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px #000;
            z-index: 10;
            pointer-events: none;
            font-size: 32px;
            font-weight: bold;
        }

        #menuBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 2px solid white;
            padding: 10px 20px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            z-index: 20;
            border-radius: 5px;
            pointer-events: auto;
        }

        #sideMenu {
            position: absolute;
            top: 0;
            right: -350px;
            width: 300px;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            z-index: 100;
            padding: 15px;
            padding-top: 10px;
            box-sizing: border-box;
            transition: right 0.3s ease-out;
            display: flex;
            flex-direction: column;
            border-left: 2px solid #444;
            overflow-y: auto;
        }

        #sideMenu.open {
            right: 0;
        }

        .menu-opt {
            margin: 4px 0;
            padding: 10px;
            background: #333;
            cursor: pointer;
            border: 1px solid #555;
            text-align: center;
            border-radius: 5px;
            transition: all 0.2s;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            font-size: 14px;
        }

        .menu-opt.active {
            background: #4CAF50;
            border-color: #81C784;
            font-weight: bold;
        }

        #overlayScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            color: white;
        }

        .big-btn {
            padding: 20px 40px;
            font-size: 28px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            text-align: center;
        }

        .bt-btn {
            padding: 15px 30px;
            font-size: 18px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            max-width: 90vw;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            text-align: center;
        }

        .bt-btn.connected {
            background: #4CAF50;
            cursor: default;
        }

        .bt-btn.connecting {
            background: #FF9800;
        }

        .restart-btn {
            padding: 15px 30px;
            font-size: 22px;
            background: #FF9800;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 10px;
        }

        .close-btn {
            align-self: flex-end;
            background: none;
            border: none;
            color: white;
            font-size: 30px;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .menu-section {
            margin-bottom: 20px;
        }

        .menu-label {
            font-size: 16px;
            margin-bottom: 8px;
            color: #aaa;
            font-weight: bold;
        }

        .vibration-feedback {
            position: absolute;
            bottom: 80px;
            left: 20px;
            padding: 10px;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            z-index: 10;
            display: none;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <div id="loader">Loading 3D Assets...</div>
    <div id="hud">
        <div id="score" style="font-size: 24px;">Score: 0</div>
    </div>
    <div id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>

    <button id="menuBtn" style="display: none;">Menu</button>

    <div id="sideMenu">
        <button class="close-btn" id="closeMenu">√ó</button>

        <div class="menu-section">
            <div class="menu-label" id="langLabel">Language</div>
            <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                <div class="menu-opt" onclick="setLanguage('en')">EN</div>
                <div class="menu-opt" onclick="setLanguage('de')">DE</div>
                <div class="menu-opt" onclick="setLanguage('fr')">FR</div>
                <div class="menu-opt" onclick="setLanguage('es')">ES</div>
                <div class="menu-opt" onclick="setLanguage('it')">IT</div>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-label" id="diffLabel">Difficulty</div>
            <div class="menu-opt" id="diff-easy" onclick="setDifficulty('easy')">Easy</div>
            <div class="menu-opt" id="diff-medium" onclick="setDifficulty('medium')">Medium</div>
            <div class="menu-opt" id="diff-hard" onclick="setDifficulty('hard')">Hard</div>
        </div>

        <div class="menu-section">
            <div class="menu-label" id="controlLabel">Control Mode</div>
            <div class="menu-opt" id="ctrl-keyboard" onclick="setControlMode('keyboard')">Keyboard</div>
            <div class="menu-opt" id="ctrl-vibe-hand" onclick="setControlMode('vibe-hand')">Hand Controller</div>
            <div class="menu-opt" id="ctrl-vibe-foot" onclick="setControlMode('vibe-foot')">Foot Pedal</div>
        </div>
    </div>

    <div id="vibe-feedback" class="vibration-feedback"></div>

    <div id="app"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const translations = {
            en: {
                start: "START ADVENTURE",
                crashed: "CRASHED!",
                score: "Score",
                playAgain: "Play Again",
                pressRestart: "Press any key to restart",
                newRecord: "NEW RECORD!",
                easy: "Easy",
                medium: "Medium",
                hard: "Hard",
                keyboard: "Keyboard",
                vibeHand: "Hand Controller",
                vibeFoot: "Foot Pedal",
                lang: "Language",
                difficulty: "Difficulty",
                controlMode: "Control Mode",
                btConnect: "Connect Bluetooth Device",
                btConnected: "Bluetooth Connected",
                btConnecting: "Connecting...",
                btError: "Connection Failed",
                btFeatureNotSupported: "Bluetooth not supported",
                btRequestCancelled: "Search cancelled",
                btDisconnected: "Bluetooth Disconnected"
            },
            de: {
                start: "ABENTEUER STARTEN",
                crashed: "GEKRASHED!",
                score: "Punktzahl",
                playAgain: "Nochmal spielen",
                pressRestart: "Taste dr√ºcken zum Neustarten",
                newRecord: "NEUER REKORD!",
                easy: "Einfach",
                medium: "Mittel",
                hard: "Schwer",
                keyboard: "Tastatur",
                vibeHand: "Handcontroller",
                vibeFoot: "Fu√üpedal",
                lang: "Sprache",
                difficulty: "Schwierigkeit",
                controlMode: "Steuerungsmodus",
                btConnect: "Bluetooth-Ger√§t verbinden",
                btConnected: "Bluetooth verbunden",
                btConnecting: "Verbindung wird hergestellt...",
                btError: "Verbindung fehlgeschlagen",
                btFeatureNotSupported: "Bluetooth nicht unterst√ºtzt",
                btRequestCancelled: "Suche abgebrochen",
                btDisconnected: "Bluetooth getrennt"
            },
            fr: {
                start: "COMMENCER L'AVENTURE",
                crashed: "ACCIDENT!",
                score: "Score",
                playAgain: "Rejouer",
                pressRestart: "Appuyez sur une touche",
                newRecord: "NOUVEAU RECORD!",
                easy: "Facile",
                medium: "Moyen",
                hard: "Difficile",
                keyboard: "Clavier",
                vibeHand: "Contr√¥leur Manuel",
                vibeFoot: "P√©dale",
                lang: "Langue",
                difficulty: "Difficult√©",
                controlMode: "Mode de contr√¥le",
                btConnect: "Connecter l'appareil Bluetooth",
                btConnected: "Bluetooth connect√©",
                btConnecting: "Connexion...",
                btError: "√âchec de connexion",
                btFeatureNotSupported: "Bluetooth non support√©",
                btRequestCancelled: "Recherche annul√©e",
                btDisconnected: "Bluetooth d√©connect√©"
            },
            es: {
                start: "INICIAR AVENTURA",
                crashed: "¬°CHOQUE!",
                score: "Puntuaci√≥n",
                playAgain: "Jugar de nuevo",
                pressRestart: "Presiona una tecla",
                newRecord: "¬°NUEVO R√âCORD!",
                easy: "F√°cil",
                medium: "Medio",
                hard: "Dif√≠cil",
                keyboard: "Teclado",
                vibeHand: "Control Manual",
                vibeFoot: "Pedal",
                lang: "Idioma",
                difficulty: "Dificultad",
                controlMode: "Modo de control",
                btConnect: "Conectar dispositivo Bluetooth",
                btConnected: "Bluetooth conectado",
                btConnecting: "Conectando...",
                btError: "Error de conexi√≥n",
                btFeatureNotSupported: "Bluetooth no soportado",
                btRequestCancelled: "B√∫squeda cancelada",
                btDisconnected: "Bluetooth desconectado"
            },
            it: {
                start: "INIZIA AVVENTURA",
                crashed: "INCIDENTE!",
                score: "Punteggio",
                playAgain: "Gioca ancora",
                pressRestart: "Premi un tasto",
                newRecord: "NUOVO RECORD!",
                easy: "Facile",
                medium: "Medio",
                hard: "Difficile",
                keyboard: "Tastiera",
                vibeHand: "Controller Manuale",
                vibeFoot: "Pedale",
                lang: "Lingua",
                difficulty: "Difficolt√†",
                controlMode: "Modalit√† di controllo",
                btConnect: "Connetti dispositivo Bluetooth",
                btConnected: "Bluetooth connesso",
                btConnecting: "Connessione...",
                btError: "Connessione fallita",
                btFeatureNotSupported: "Bluetooth non supportato",
                btRequestCancelled: "Ricerca annullata",
                btDisconnected: "Bluetooth disconnesso"
            }
        };

        const VIBE_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
        const VIBE_TX_CHAR_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
        const VIBE_RX_CHAR_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";

        function Game() {
            const [gameStarted, setGameStarted] = useState(false);
            const [gameOver, setGameOver] = useState(false);
            const [score, setScore] = useState(0);
            const [lives, setLives] = useState(3);
            const [newRecord, setNewRecord] = useState(false);
            const [language, setLanguageState] = useState('en');
            const [difficulty, setDifficultyState] = useState('medium');
            const [controlMode, setControlModeState] = useState('keyboard');
            const [menuOpen, setMenuOpen] = useState(false);

            const [btStatus, setBtStatus] = useState('disconnected');
            const [btDevice, setBtDevice] = useState(null);
            const [txChar, setTxChar] = useState(null);

            const gameStateRef = useRef({
                carX: 0,
                score: 0,
                lives: 3,
                isGameOver: false,
                isPaused: false,
                gameStarted: false,
                speed: 0.8,
                opponents: [],
                gridRows: [],
                difficulty: 'medium',
                controlMode: 'keyboard',
                lastVibeUpdate: 0,
                vibeIntensity: 0,
                vibeHistory: [],
                totalDistance: 0,
                movingTime: 0
            });

            const t = (key) => translations[language][key] || key;

            const updateLanguageLabels = useCallback(() => {
                document.getElementById('langLabel').textContent = t('lang');
                document.getElementById('diffLabel').textContent = t('difficulty');
                document.getElementById('controlLabel').textContent = t('controlMode');
                document.getElementById('diff-easy').textContent = t('easy');
                document.getElementById('diff-medium').textContent = t('medium');
                document.getElementById('diff-hard').textContent = t('hard');
                document.getElementById('ctrl-keyboard').textContent = t('keyboard');
                document.getElementById('ctrl-vibe-hand').textContent = t('vibeHand');
                document.getElementById('ctrl-vibe-foot').textContent = t('vibeFoot');
            }, [language]);

            useEffect(() => {
                updateLanguageLabels();
            }, [language, updateLanguageLabels]);

            const connectBluetooth = async () => {
                if (!navigator.bluetooth) {
                    alert(t('btFeatureNotSupported'));
                    return;
                }

                try {
                    setBtStatus('connecting');
                    const device = await navigator.bluetooth.requestDevice({
                        filters: [{ namePrefix: 'Vibe' }, { services: [VIBE_SERVICE_UUID] }],
                        optionalServices: [VIBE_SERVICE_UUID]
                    });

                    device.addEventListener('gattserverdisconnected', onDisconnected);

                    const server = await device.gatt.connect();
                    const service = await server.getPrimaryService(VIBE_SERVICE_UUID);
                    const tx = await service.getCharacteristic(VIBE_TX_CHAR_UUID);
                    const rx = await service.getCharacteristic(VIBE_RX_CHAR_UUID);

                    setBtDevice(device);
                    setTxChar(tx);
                    setBtStatus('connected');

                    rx.startNotifications().then(() => {
                        rx.addEventListener('characteristicvaluechanged', handleRxData);
                    });

                } catch (error) {
                    console.error("BT Connection Error:", error);
                    setBtStatus('disconnected');
                    if (error.name !== 'NotFoundError') {
                        alert(t('btError') + ": " + error.message);
                    }
                }
            };

            const onDisconnected = () => {
                setBtStatus('disconnected');
                setBtDevice(null);
                setTxChar(null);
                alert(t('btDisconnected'));
            };

            const handleRxData = (event) => {
                const value = event.target.value;
                const decoder = new TextDecoder();
                const str = decoder.decode(value);
                const ref = gameStateRef.current;

                if (ref.controlMode.startsWith('vibe')) {
                    const lines = str.split('\n');
                    for (let line of lines) {
                        if (line.startsWith('A:')) {
                            const accel = parseFloat(line.split(':')[1]);
                            if (!isNaN(accel)) {
                                ref.carX = Math.max(-10, Math.min(10, -accel * 0.8));
                            }
                        }
                    }
                }
            };

            const sendVibeData = async (intensity) => {
                if (!txChar || btStatus !== 'connected') return;

                const ref = gameStateRef.current;
                const now = Date.now();
                if (now - ref.lastVibeUpdate < 100) return;

                const i = Math.floor(Math.max(0, Math.min(100, intensity)));
                if (i === ref.vibeIntensity && i !== 0) return;

                try {
                    const encoder = new TextEncoder();
                    const data = encoder.encode(`V:${i}\n`);
                    await txChar.writeValueWithoutResponse(data);
                    ref.lastVibeUpdate = now;
                    ref.vibeIntensity = i;
                } catch (e) {
                    console.error("Vibe Send Error", e);
                }
            };

            useEffect(() => {
                const highscore = localStorage.getItem('highscore_car') || 0;
                let scene, camera, renderer, car, clock;
                let frameId;

                const init = () => {
                    scene = new THREE.Scene();
                    scene.background = new THREE.Color(0x000000);
                    scene.fog = new THREE.Fog(0x000000, 10, 300);

                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.set(0, 5, 10);
                    camera.lookAt(0, 0, -10);

                    renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    document.getElementById('app').appendChild(renderer.domElement);

                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    scene.add(ambientLight);

                    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    sunLight.position.set(50, 100, 50);
                    scene.add(sunLight);

                    const carGroup = new THREE.Group();
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.8, 4),
                        new THREE.MeshStandardMaterial({ color: 0xff0000 })
                    );
                    body.position.y = 0.6;
                    carGroup.add(body);

                    const cabin = new THREE.Mesh(
                        new THREE.BoxGeometry(1.6, 0.8, 2),
                        new THREE.MeshStandardMaterial({ color: 0x333333 })
                    );
                    cabin.position.set(0, 1.4, -0.2);
                    carGroup.add(cabin);

                    const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 16);
                    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                    const wheels = [
                        { x: -1, y: 0.4, z: 1.2 }, { x: 1, y: 0.4, z: 1.2 },
                        { x: -1, y: 0.4, z: -1.2 }, { x: 1, y: 0.4, z: -1.2 }
                    ];
                    wheels.forEach(pos => {
                        const w = new THREE.Mesh(wheelGeo, wheelMat);
                        w.rotation.z = Math.PI / 2;
                        w.position.set(pos.x, pos.y, pos.z);
                        carGroup.add(w);
                    });

                    car = carGroup;
                    scene.add(car);

                    const roadWidth = 25;
                    const gridCount = 50;
                    const gridSpacing = 15;

                    for (let i = 0; i < gridCount; i++) {
                        const row = new THREE.Group();
                        const lineGeo = new THREE.PlaneGeometry(roadWidth, 0.2);
                        const lineMat = new THREE.MeshBasicMaterial({ color: 0x444444 });
                        const line = new THREE.Mesh(lineGeo, lineMat);
                        line.rotation.x = -Math.PI / 2;
                        row.add(line);

                        const dashGeo = new THREE.PlaneGeometry(0.4, 3);
                        const dashMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                        const dash = new THREE.Mesh(dashGeo, dashMat);
                        dash.rotation.x = -Math.PI / 2;
                        dash.position.y = 0.05;
                        row.add(dash);

                        row.position.z = -i * gridSpacing;
                        scene.add(row);
                        gameStateRef.current.gridRows.push(row);
                    }

                    clock = new THREE.Clock();
                    document.getElementById('loader').style.opacity = '0';
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                    document.getElementById('menuBtn').style.display = 'block';

                    animate();
                };

                const spawnOpponent = () => {
                    const ref = gameStateRef.current;
                    if (!ref.gameStarted || ref.isGameOver || ref.isPaused) return;

                    const colors = [0x0000ff, 0xffff00, 0x00ff00, 0xff00ff, 0x00ffff];
                    const opp = new THREE.Group();
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.8, 3.8),
                        new THREE.MeshStandardMaterial({ color: colors[Math.floor(Math.random() * colors.length)] })
                    );
                    body.position.y = 0.6;
                    opp.add(body);
                    opp.position.set((Math.random() - 0.5) * 20, 0, -300);
                    scene.add(opp);
                    ref.opponents.push({ mesh: opp, speed: 0.4 + Math.random() * 0.4 });
                };

                const animate = () => {
                    frameId = requestAnimationFrame(animate);
                    const delta = clock.getDelta();
                    const ref = gameStateRef.current;

                    if (ref.gameStarted && !ref.isGameOver && !ref.isPaused) {
                        ref.totalDistance += ref.speed;
                        ref.movingTime += delta;
                        const currentScore = Math.floor(ref.totalDistance / 10);
                        if (currentScore !== ref.score) {
                            ref.score = currentScore;
                            setScore(currentScore);
                        }

                        let moveSpeed = 15 * delta;
                        if (ref.difficulty === 'hard') moveSpeed *= 1.5;
                        if (ref.difficulty === 'easy') moveSpeed *= 0.7;

                        if (ref.controlMode === 'keyboard') {
                            if (keys['ArrowLeft'] || keys['a']) ref.carX -= moveSpeed;
                            if (keys['ArrowRight'] || keys['d']) ref.carX += moveSpeed;
                        }

                        ref.carX = Math.max(-11, Math.min(11, ref.carX));
                        car.position.x = THREE.MathUtils.lerp(car.position.x, ref.carX, 0.1);
                        car.rotation.y = -(car.position.x - ref.carX) * 0.05;
                        car.rotation.z = -(car.position.x - ref.carX) * 0.02;

                        ref.gridRows.forEach(row => {
                            row.position.z += ref.speed * 60 * delta;
                            if (row.position.z > 20) {
                                row.position.z -= 50 * 15;
                            }
                        });

                        if (Math.random() < 0.02) spawnOpponent();

                        for (let i = ref.opponents.length - 1; i >= 0; i--) {
                            const opp = ref.opponents[i];
                            opp.mesh.position.z += (ref.speed + opp.speed) * 60 * delta;

                            const dist = car.position.distanceTo(opp.mesh.position);
                            if (dist < 2.5) {
                                ref.lives--;
                                setLives(ref.lives);
                                scene.remove(opp.mesh);
                                ref.opponents.splice(i, 1);
                                if (btStatus === 'connected') sendVibeData(100);

                                if (ref.lives <= 0) {
                                    ref.isGameOver = true;
                                    setGameOver(true);
                                    if (ref.score > highscore) {
                                        localStorage.setItem('highscore_car', ref.score);
                                        setNewRecord(true);
                                    }
                                }
                                continue;
                            }

                            if (opp.mesh.position.z > 20) {
                                scene.remove(opp.mesh);
                                ref.opponents.splice(i, 1);
                            }
                        }
                    }

                    renderer.render(scene, camera);
                };

                const keys = {};
                window.onkeydown = (e) => {
                    keys[e.key] = true;
                    if (gameStateRef.current.isGameOver) {
                        window.location.reload();
                    }
                };
                window.onkeyup = (e) => keys[e.key] = false;

                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);

                init();

                return () => {
                    cancelAnimationFrame(frameId);
                    window.removeEventListener('resize', handleResize);
                };
            }, []);

            const setLanguage = (lang) => {
                setLanguageState(lang);
                setMenuOpen(false);
            };

            const setDifficulty = (diff) => {
                setDifficultyState(diff);
                gameStateRef.current.difficulty = diff;
                document.querySelectorAll('#diffLabel + div .menu-opt').forEach(el => el.classList.remove('active'));
                document.getElementById('diff-' + diff).classList.add('active');
            };

            const setControlMode = (mode) => {
                setControlModeState(mode);
                gameStateRef.current.controlMode = mode;
                document.querySelectorAll('#controlLabel + div .menu-opt').forEach(el => el.classList.remove('active'));
                document.getElementById('ctrl-' + mode).classList.add('active');
            };

            useEffect(() => {
                const m = document.getElementById('sideMenu');
                if (menuOpen) m.classList.add('open');
                else m.classList.remove('open');
            }, [menuOpen]);

            useEffect(() => {
                document.getElementById('menuBtn').onclick = () => setMenuOpen(true);
                document.getElementById('closeMenu').onclick = () => setMenuOpen(false);
                window.setLanguage = setLanguage;
                window.setDifficulty = setDifficulty;
                window.setControlMode = setControlMode;

                setDifficulty('medium');
                setControlMode('keyboard');
            }, []);

            const startGame = () => {
                setGameStarted(true);
                gameStateRef.current.gameStarted = true;
            };

            const onPlayAgain = () => {
                window.location.reload();
            };

            return (
                <>
                    {!gameStarted && !gameOver && (
                        <div id="overlayScreen">
                            <h1 style={{ fontSize: '60px', marginBottom: '10px' }}>Car Adventure</h1>
                            <button className="big-btn" onClick={startGame}>{t('start')}</button>
                            <button
                                className={`bt-btn ${btStatus === 'connected' ? 'connected' : btStatus === 'connecting' ? 'connecting' : ''}`}
                                onClick={btStatus === 'disconnected' ? connectBluetooth : null}
                            >
                                {btStatus === 'connected' ? `‚úì ${t('btConnected')}` :
                                    btStatus === 'connecting' ? t('btConnecting') :
                                        `üì± ${t('btConnect')}`}
                            </button>
                        </div>
                    )}

                    {gameOver && (
                        <div id="overlayScreen">
                            <h1 style={{ color: '#ff4444', fontSize: '80px', margin: 0 }}>{t('crashed')}</h1>
                            <p style={{ fontSize: '32px' }}>{t('score')}: {score}</p>
                            {newRecord && <div style={{ background: '#FFD700', color: 'black', padding: '10px 20px', borderRadius: '5px', fontWeight: 'bold', fontSize: '20px', marginBottom: '20px' }}>üèÜ {t('newRecord')} üèÜ</div>}
                            <p style={{ fontSize: '18px', color: '#aaa' }}>{t('pressRestart')}</p>
                            <button className="big-btn" onClick={onPlayAgain}>{t('playAgain')}</button>
                            <div style={{ marginTop: '15px' }}>
                                <button className="restart-btn" onClick={() => {
                                    setGameStarted(false); setGameOver(false); setScore(0); setLives(3); setNewRecord(false); setMenuOpen(false);
                                    const ref = gameStateRef.current;
                                    ref.isGameOver = false; ref.isPaused = false; ref.gameStarted = false;
                                    ref.score = 0; ref.lives = 3; ref.movingTime = 0; ref.totalDistance = 0;
                                    ref.opponents.forEach(o => { if (o.mesh && o.mesh.parent) o.mesh.parent.remove(o.mesh); });
                                    ref.opponents = [];
                                    for (let i = 0; i < ref.gridRows.length; i++) {
                                        ref.gridRows[i].z = -350 + (i * 15);
                                    }
                                }}>Main Menu</button>
                            </div>
                        </div>
                    )}

                    <div id="lives-display" style={{ display: 'none' }}>
                        {Array(lives).fill('‚ù§Ô∏è').join('')}
                    </div>
                </>
            );
        }

        ReactDOM.render(<Game />, document.getElementById('app'));

        useEffect(() => {
            const l = document.getElementById('lives');
            l.innerHTML = Array(lives).fill('‚ù§Ô∏è').join('');
        }, [lives]);
    </script>
</body>

</html>
